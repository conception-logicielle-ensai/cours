---
url: /docs/persistence-des-donnees/
title: üõ¢ Persistence des donn√©es
---


Lorsque l'on execute un programme, il utilise une m√©moire qui lui est allou√©e pour pouvoir fonctionner. 
A la fin de l'execution du programme la m√©moire est d√©sallou√©e et donc tout ce qui √©tait dans le contexte d'execution du programme n'est plus accessible.

C'est ainsi que vient la notion de persistence des donn√©es qui se pr√©sente comme la n√©cessit√© de pouvoir sauvegarder les r√©sultats et √©tats du syst√®me pour conserver des √©l√©ments d√©j√† trait√©s.

En g√©n√©ral, on s√©pare le stockage des donn√©es d'un programme entre des fichiers et des bases de donn√©es.

> **Comme pour les autres parties, les exemples sont disponibles ici : [https://github.com/conception-logicielle-ensai/exemples-cours/tree/main/cours-5/persistence](https://github.com/conception-logicielle-ensai/exemples-cours/tree/main/cours-5/persistence)**

<div class="alert alert-info">
  <strong> Pour aller plus loin </strong> 

Un site qui vulgarise l'execution du code python c√¥t√© machine  [https://pythontutor.com/python-compiler.html#mode=edit](https://pythontutor.com/python-compiler.html#mode=edit)

</div>

<div class="alert alert-info">
  <strong> Pour aller plus loin </strong>

Petite vid√©o sur le fonctionnement stack vs heap : [https://www.youtube.com/watch?v=5OJRqkYbK-4](https://www.youtube.com/watch?v=5OJRqkYbK-4)

</div>

## Fichiers

<img style="max-width:20%;margin-left: auto; margin-right:auto" src="https://cdn-icons-png.flaticon.com/512/3979/3979301.png" />

Les fichiers peuvent avoir diff√©rents formats pour stocker de la donn√©e

- les fichiers au format de texte: **csv**, **txt**, **xml**, **json**, **yaml**
- les fichiers au format binaire : **parquet**, **zip**, ...

Les fichiers peuvent √™tre ensuite import√©s ou export√©s depuis le code, exemple avec du `json`:

```python
import json

# Donn√©es √† sauvegarder
data = {"utilisateurs": [{"nom": "Alice", "age": 30}, {"nom": "Bob", "age": 25}]}

# √âcriture dans un fichier JSON
with open("data.json", "w") as f:
    json.dump(data, f, indent=4)

# Lecture du fichier JSON
with open("data.json", "r") as f:
    data = json.load(f)
    print(data)
```

Ces fichiers sont ensuite stock√©s directement aupr√®s du serveur qui execute le processus en local (par exemple votre poste de travail quand vous √™tes en local) et peuvent √™tre synchronis√© et stock√©s dans des espaces adapt√©s. 

Par exemple, on pourrait vouloir, a la fin d'un processus sauvegarder les fichiers construits par nos traitement dans des services de stockage de fichier de type S3, ces services permettant d'h√©berger a faible co√ªt et avec facilit√© d'acc√®s, des fichiers non structur√©s.

<div class="alert alert-info">
  <strong> Pour aller plus loin </strong> <br/>
    Stockage objet, client s3 python : <a href="https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/s3.html">boto3</a>
</div>

<div class="alert alert-info">
  <strong> Pour aller plus loin </strong> 

Documentation d'utilisation du stockage S3 sur les espaces du datalab sspcloud : 
[https://docs.sspcloud.fr/content/storage.html](
https://docs.sspcloud.fr/content/storage.html)

</div>


## Syst√®mes de gestion de base de donn√©es (SGBD)

<img style="max-width:60%;margin-left: auto; margin-right:auto" src="https://www.ovhcloud.com/sites/default/files/styles/large_screens_1x/public/2019-09/enterprise-cloud-database.png" />

Dans cette partie nous nous interesserons sp√©cifiquement aux bases de donn√©es `relationnelles` et `document`.

### Bases de donn√©es relationnelles

Les bases de donn√©es de donn√©es relationnelles sont des bases dans lesquelles les donn√©es sont organis√©es sous forme de table.
On les pr√©conise dans des cas o√π l'architecture sous tend une structure des donn√©es fixe. 

‚úÖ Avantages :
- Coh√©rence et int√©grit√© des donn√©es gr√¢ce aux relations.
- Bonne optimisation pour les requ√™tes complexes.

‚ùå Inconv√©nients :
- Peu flexible : toute modification de la structure n√©cessite des migrations.
- Moins performant pour des donn√©es non structur√©es ou fortement imbriqu√©es.

> Exemples : MySQL, SQLite, PostgreSQL, H2

### Bases de donn√©es orient√©es document

Les bases de donn√©es document permettent le stockage de donn√©es sous des formats flexibles, a base de document g√©n√©ralement en `JSON` ou `BSON` (compress√©).
Les documents n'ont pas a respecter un sch√©ma propre et puisqu'il n'y a pas de contraintes, les bdd document sont optimis√©es pour des requ√™tes sur le contenu des documents.

‚úÖ Avantages :

- Donn√©es non structur√©es : on peut modifier la structure des donn√©es facilement.
- Performant pour les applications √† forte scalabilit√© (ex : applications web, big data) .
- Id√©al pour stocker des donn√©es complexes (ex : profils utilisateurs avec param√®tres vari√©s, nullables).

‚ùå Inconv√©nients :

- Moins adapt√© aux transactions complexes et aux relations entre les donn√©es.
- Peut poser des probl√®mes d'int√©grit√© des donn√©es en raison du manque de normalisation.

> Exemples : MongoDB, CouchDB (accessible en via api rest)...

> **Remarque : Lors de vos choix de conception , il faudra privil√©gier une base de donn√©es coh√©rente avec votre architecture si vous avez besoin de persister des donn√©es en base de donn√©es**

## Fiabilit√© et Performance des Bases de Donn√©es

### Transactions et ACID

<img style="max-width:60%;margin-left: auto; margin-right:auto" src="https://www.scylladb.com/wp-content/uploads/acid-diagram.png" />
Les bases de donn√©es relationnelles impl√©mentent les principes ACID (`Atomicit√©` `Coh√©rence` `Isolation` `Durabilit√©`) pour leurs transactions.

**Atomicit√©**: Une transaction est toujours **tout ou rien**

Exemple:

Dans le cas d'un transfert bancaire, si il y a un dysfonctionnement il n'y aura pas de situation ou une personne re√ßoit de l'argent que l'autre personne a encore dans son compte en banque.

**Coh√©rence**: Une transaction assure que les donn√©es transf√©r√©es ne sont pas corrompues ou respectent des r√®gles fix√©es dans le mod√®le (pas d'identifiant null...)
> Cela permet de stopper un traitement en cas de corruption et de rollback

**Isolation**: Les transactions s'executent ind√©pendamment les unes des autres.
> Cela permet d'√©viter les conflits
**Durabilit√©**: Les donn√©es, apr√®s la transaction sont bien persist√©es m√™me si il y a une panne

Une transaction comment par un `BEGIN` et finit au `COMMIT`. On peut donc r√©aliser plusieurs modifications dans une m√™me transaction.

#### Au niveau du code python

On peut donc effectuer plusieurs modification au sein d'une m√™me transaction, exemple (avec psycopg2).

```python
import psycopg2

try:
    # il faut executer le script rollback-initdb.sql pour tester
    conn = psycopg2.connect(dbname="postgres", user="postgres", password="postgres", host="localhost")
    cursor = conn.cursor()
    cursor.execute("BEGIN")
    cursor.execute("INSERT INTO users (name, age) VALUES (%s, %s)", ("Alice", 25))
    cursor.execute("INSERT INTO users (name, age) VALUES (%s, %s)", ("Bob", 35))
    conn.commit()
except Exception as e:
    conn.rollback()
    print("Erreur :", e)
finally:
    cursor.close()
    conn.close()
```

> MongoDB impl√©mente √©galement ce principe, cela assure une bonne gestion des √©volutions des donn√©es.

### Formes normales

Les formes normales d√©crivent des r√®gles qui assurent la bonne organisation des donn√©es et √©vitent la redondance.

- **1√®re forme normale (1NF) :** Chaque colonne contient des valeurs atomiques, et chaque ligne est unique.

Il faut donc ici ne pas mettre de valeurs qui contient une liste de valeurs, on privil√©gie de mettre en place 
- **2√®me forme normale (2NF) :** Respecte la 1NF et assure qu'il n'y a pas de d√©pendances partielles.

Il ne faut pas que des champs soient interd√©pendants entre eux exactement. (un champ ne doit pas √™tre en correlation totale avec un autre champ)

- **3√®me forme normale (3NF) :** Respecte la 2NF et supprime les d√©pendances transitives.

Il faut ici que les champs dans nos tables soient non correl√©s des champs que l'on pourrait retrouver sans jointure directe par des cl√©s dans une autre table.

Soit encore : 

Il faut ici que les informations dans une table soient directement li√©es √† la cl√© primaire de cette table, et non √† une colonne non-cl√© (2NF). Les colonnes non-cl√© ne doivent pas d√©pendre les unes des autres (1NF), et toute relation entre les informations d'autres tables doit se faire via des cl√©s √©trang√®res et non par des d√©pendances directes entre colonnes non-cl√©.

#### Exemple

Voici un exemple pr√©sentant une table qui respecte la 1√®re forme normale mais pas la 2√®me.

```sql
CREATE TABLE students_courses (
    student_id INT,
    student_name VARCHAR(100),
    course_name VARCHAR(100),
    course_instructor VARCHAR(100),
    PRIMARY KEY (student_id, course_name)
);

INSERT INTO students_courses (student_id, student_name, course_name, course_instructor) 
VALUES
(1, 'Bob', 'Math', 'Dr. Smith'),
(1, 'Bob', 'Physics', 'Dr. Brown'),
(2, 'Alice', 'Math', 'Dr. Smith'),
(2, 'Alice', 'Biology', 'Dr. White');
```

- On voit bien ici qu'il y a atomicit√© des donn√©es ligne a ligne, par contre on rep√®te les informations d√©pendantes : le cours et le professeur sont correl√©s.

Il faut donc d√©couper en 2 tables avec une table d'association, pour isoler les donn√©es venant du cours, des donn√©es des √©l√®ves.

```sql
CREATE TABLE students (
    student_id INT PRIMARY KEY,
    student_name VARCHAR(100)
);

CREATE TABLE courses (
    course_id INT PRIMARY KEY,
    course_name VARCHAR(100),
    course_instructor VARCHAR(100)
);

CREATE TABLE student_courses (
    student_id INT,
    course_id INT,
    PRIMARY KEY (student_id, course_id),
    FOREIGN KEY (student_id) REFERENCES students(student_id),
    FOREIGN KEY (course_id) REFERENCES courses(course_id)
);
```

```sql
INSERT INTO students (student_id, student_name) VALUES
(1, 'Bob'),
(2, 'Alice');

INSERT INTO courses (course_name, course_instructor) VALUES
(1,'Math', 'Dr. Smith'),
(2,'Physics', 'Dr. Brown'),
(3,'Biology', 'Dr. White');

INSERT INTO student_courses (student_id,course_id) VALUES
(1, 1),
(1, 2),
(2, 1),
(2, 3);
```

### Performances

Les bases de donn√©es relationnelles reposent leurs optimisations sur des fonctionnalit√©s de calcul de statistiques `Analyze`. Elle suivent ensuite des **plans d'executions** selon les donn√©es collect√©es et pr√©calcul√©es sur la bases de donn√©es.

Pour les performances on peut √™tre amen√©s a utiliser les m√©thodes suivantes : 
- Indexation : On d√©finit une cl√© homog√®ne pour acc√®der a des donn√©es - √©quivalent de pr√©calculer une clause where par exemple
- D√©normalisation : On copie les donn√©es dans une autre table plus petite pour avoir moins de colonnes a r√©cup√©rer, cela permet d'acc√©der plus vite aux informations.
- Vues: On pr√©calcule un ensemble de donn√©es que l'on peut ensuite cacher c√¥t√© BDD.

<div class="alert alert-info">
    <strong> Pour aller plus loin </strong>

Instagram et la d√©normalisation : Le **Justin Bieber Problem** : https://medium.com/@AVTUNEY/how-instagram-solved-the-justin-bieber-problem-using-postgresql-denormalization-86b0fdbad94b

</div>

## Impl√©mentations

<img src="https://infodocbib.net/wp-content/uploads/2020/06/Seq4-BddCollegeXYZCoursB.png" />


### SQL - Base de donn√©es embarqu√©e, exemple avec SQLite

<img style="max-width:80%;margin-left: auto; margin-right:auto" src="https://www.fullstackpython.com/img/logos/sqlite.jpg" />

[SQLite](https://www.sqlite.org/index.html) 

est un syst√®me de base de donn√©es embarqu√©. A la diff√©rence des syst√®mes de base de donn√©es classiques (type postgresql, oracle, mysql ...), l'architecture de SQLite ne contient pas de serveur. C'est l'application elle m√™me qui √©crit et lit les donn√©es √† partir d'un fichier `.sqlite` contenant l'ensemble des donn√©es.  
SQLite est un moteur de base de donn√©es fantastique, utilis√© dans des milliards d'appareil (vous venez de regarder vos SMS ? Votre smartphone a utilis√© SQLite. Vous venez de regarder le ciel ? Le satellite que vous voyez a tr√®s probablement des bases de donn√©es sqlite en lui). Si le sujet vous int√©resse, cette conf√©rence est formidable : https://www.youtube.com/watch?v=gpxnbly9bz4  

Pour nous, le principal avantage de SQLite va venir de son architecture simplifi√©e, il n'y a pas besoin de faire tourner de base de donn√©es ind√©pendante. 

Tutorial d'utilisation de sqlite :  
[https://www.digitalocean.com/community/tutorials/how-to-use-the-sqlite3-module-in-python-3](https://www.digitalocean.com/community/tutorials/how-to-use-the-sqlite3-module-in-python-3)

<div class="alert alert-info">
  <strong> Pour aller plus loin </strong> 

Voir l'exemple dans le cours : [https://github.com/conception-logicielle-ensai/exemples-cours/blob/main/cours-5/persistence/sqlite/sqlite.py](https://github.com/conception-logicielle-ensai/exemples-cours/blob/main/cours-5/persistence/sqlite/sqlite.py)
</div>



### Bases de donn√©es documentaires (NoSQL), exemple avec mongodb

<img style="max-width:80%;margin-left: auto; margin-right:auto" src="https://www.awelty.fr/medias/images/mongodb.png" />

Les bases de donn√©es NoSQL permettent de traiter des collections de donn√©es non structur√©es. Elles ont de nombreux avantages.

MongoDB üçÉ est un leader dans le monde des bases de donn√©es NoSQL, il permet de stocker et de traiter des calculs sur de nombreux documents.
L'int√™ret de ce type de base de donn√©es est dans l'utilisation de fonctionnalit√©s avanc√©es pour le calcul : 

- Le sharding : MongoDB prend en charge la scalabilit√© horizontale, c'est-√†-dire la possibilit√© de r√©partir les donn√©es sur plusieurs serveurs (shards).
- Haute disponibilit√© : par sa scalabilit√© on peut √©galement b√©n√©ficier de transactions rapidement en cas de mont√©e de charge.
- Indexation: Comme les autres BDD, mongoDB permet l'indexation des donn√©es, qui, pr√©calcul√©es, sont donc r√©cup√©rables tr√®s efficacement.

On peut interagir avec des moteurs permettant la connexion aux bases de donn√©es mongo, en python on privil√©giera l'utilisation de `pymongo`.

#### Exemple de code : https://github.com/conception-logicielle-ensai/exemples-cours/blob/main/cours-5/persistence/mongodb/mongo_exemple.py

MongoDB fonctionne avec des `Collections` √©quivalent des tables. Dans celle ci on peut d√©poser des donn√©es non structur√©e :

```python
# En abstrayant la connexion a la bdd
COLLECTION = "user_data"
collection = db[COLLECTION]  # Remplacez par le nom de votre collection

# Exemple d'insertion d'un document dans la collection
document = {
    "nom": "John",
    "age": 30,
    "ville": "Paris"
}
collection.insert_one(document)
```

## Object Relationnal Mapping 

L'Object-Relational Mapping (ORM) est une technique qui permet de mapper des objets du langage de programmation orient√© objet a des tables en base de donn√©es.

Il s'agit donc d'utiliser les fonctionnalit√©s de POO de python pour s√©rialiser/des√©rialiser automatiquement les donn√©es r√©cup√©r√©esen base de donn√©es.

L'ORM propose √©galement une interface de haut niveau qui permet de s'abstraire du type de base de donn√©es utilis√©es, bien qu'on utilise cela en g√©n√©ral dans des bases de donn√©es a la structure stable, des bases de donn√©es relationnelles.

Il propose finalement une interface fonctionnelle python pour ne plus avoir a d√©velopper les scripts d'acc√®s a la base de donn√©es et permet de travailler avec des bases de donn√©es de language diff√©rentes a partir du m√™me code python.

**Par exemple:**
- En local on voudrait travailler sur une base de donn√©es portable : SQLite, mysql
- Dans un environnement h√©berg√© on voudrait travailler sur une base de donn√©es : postgresql 

### SQLAlchemy

<img style="max-width:80%;margin-left: auto; margin-right:auto" src="https://miro.medium.com/v2/resize:fit:1400/0*msfsws06ImMSJYop.jpg" />
SQLAlchemy est une impl√©mentation proposant une interface d'Object Relationnal Mapping en Python. Il impl√©mente de nombreuses fonctionnalit√©s dont :
- La gestion des relations
- La gestion des injections SQL
- La gestion des connexions (pour √©viter des fuites de connexion)

Il fait cela au travers de ce qu'on appelle un `engine` qui lui m√™me s'appuie sur des connecteurs.

- En python il s'agira des connecteurs permettant de se connecter aux bases habituellement : `psycopg2` `mysql` `sqlite3`
- Dans le monde `java` on utilise l'interface `jdbc` et des impl√©mentations en fonction du type de bases de donn√©es : `org.postgresql`

La syntaxe se pr√©sente comme suit : 

On utilise le module `declarative_base` pour rendre nos classes `mapp√©es`
```python
Base = declarative_base()

# D√©finition du mod√®le pour la table "Utilisateur"
class Utilisateur(Base):
    __tablename__ = 'utilisateurs'
    
    id = Column(Integer, primary_key=True)
    nom = Column(String)
    age = Column(Integer)
```

On se connecte a la base de donn√©es, l'engine d√©termine le type par rapport au protocole de connection, ici `sqlite:`
```python
# Cr√©ation de l'engine de la base de donn√©es (ici SQLite)
engine = create_engine('sqlite:///:memory:')
```

Puis on peut interagir avec la base de donn√©es au travers de sessions <=> Transactions 

```python
# Cr√©ation d'une session pour interagir avec la base de donn√©es
Session = sessionmaker(bind=engine)
session = Session()
# Cr√©ation d'un nouvel utilisateur
nouvel_utilisateur = Utilisateur(nom="John", age=30)

# Ajout de l'utilisateur √† la session
session.add(nouvel_utilisateur)
```

<div class="alert alert-info">
    <strong> Pour aller plus loin </strong>

Voir l'exemple : [sql_alchemy.py](https://github.com/conception-logicielle-ensai/exemples-cours/blob/main/cours-5/persistence/orm/sql_alchemy.py)

</div>

<div class="alert alert-info">
    <strong> Pour aller plus loin </strong>

SqlAlchemy dans une archi projet : [exemple de thread stackoverflow](https://stackoverflow.com/questions/7478403/sqlalchemy-classes-across-files)

</div>


## Quelques pistes pour vos projets

- Travail en local avec des bases de donn√©es locales : `mysql` `sqlite` (partage du fichier db √©ventuellement ou d'un db au d√©marrage)

- Installation de bases de donn√©es `postgresql` `mongodb` sur les instances du `SSPCLOUD`. Attention, elles seront uniquement accessible du cluster et donc d'un vscode dans le cluster.

- Installation des bases de donn√©es en local :

**Mongodb** : Suivre la documentation ici [https://www.mongodb.com/docs/manual/tutorial/install-mongodb-on-ubuntu/](https://www.mongodb.com/docs/manual/tutorial/install-mongodb-on-ubuntu/)
**Postgresql**: Suivre la documentation ici []

- Utilisation de docker (voir slide prochain cours)

**Mongodb**: `docker run -d --name mongodb -e MONGO_INITDB_ROOT_USERNAME=admin -e MONGO_INITDB_ROOT_PASSWORD=motdepasseadmin -p 27017:27017 mongo`
**Postgresql**: `docker run postgres -d -e POSTGRES_USER=admin -e POSTGRES_PASSWORD=motdepasseadmin -e POSTGRES_DB=postgres -p 5432:5432` 

**Attendus projets**: Il sera attendu de vous de nous fournir un script d'initialisation de base de donn√©es ou un fichier pour d√©marrer dans votre projet si vous impl√©mentez de la persistence.
