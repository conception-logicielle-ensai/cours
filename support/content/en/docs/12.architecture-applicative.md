---
title: üß± Architecture applicative
url: "docs/architecture-applicative"
---

Cette partie est largement inspir√©e des concepts et exemples pr√©sent√©s dans le livre :

> **Clean Architecture**, A Craftsman's Guide to Software Structure and Design. Robert C. Martin 2017.

## Architecture applicative : une d√©finition

L'architecture applicative d√©signe l'organisation structurelle d'une application logicielle, englobant ses composants, leurs interactions et les principes sous-jacents √† leur conception. Elle √©tablit une feuille de route qui guide le d√©veloppement, le d√©ploiement, et l'√©volution de l'application en fonction des besoins techniques, fonctionnels et strat√©giques.

> En d'autres termes c'est une organisation propos√©e des sources de nos programmes qui permet ensuite une bonne √©volution de celui ci.

Mais pour quel but?

> **The goal of software architecture is to minimize the human resources required to build and maintain the required system.**

## Priorisation, matrice d'Eisenhower

La r√©alisation de travaux et de programmes est consommatrice de temps et de ressources humaines, il est donc important d'identifier les t√¢ches a faire et les ordonner selon leur importance et leur criticit√©.


| Urgence et Importance | Action a faire          |
|---------------------|--------------------------------------|
| **Urgent et Important**         | √Ä faire rapidement.|
| **Urgent et non important**     | D√©l√©guer si possible : Ces t√¢ches sont urgentes mais ont un impact moindre. Exemple : r√©pondre √† certains e-mails ou r√©soudre des probl√®mes mineurs. |
| **Non Urgent mais important**    | √Ä planifier : Ces t√¢ches doivent √™tre int√©gr√©es dans votre emploi du temps pour garantir leur r√©alisation sans pression. |
| **Non Urgent et non important** | √âliminer ou minimiser : Ces activit√©s n‚Äôapportent pas de valeur ajout√©e et peuvent √™tre une perte de temps. Exemple : les distractions inutiles ou les t√¢ches peu significatives. |

Pour utiliser cette matrices:

- Listez toutes vos t√¢ches.
- Classez-les dans l‚Äôun des quatre quadrants.

Vous pouvez ensuite affiner la difficult√© des diff√©rentes t√¢ches a effectuer pour vous permettre d'identifier des priorit√©s a la r√©alisation de ces t√¢ches. Puis enfin organiser vos √©quipes pour r√©aliser ces t√¢ches dans des d√©lais raisonnables.

Dans l'√©volution des m√©thodes de travail, l'√©mergence des m√©thodes agiles propose une organisation du travail autour de cette planification au plus proche du besoin.

> Pour aller plus loin : https://fr.wikipedia.org/wiki/M%C3%A9thode_agile

## Modules et fonctions

Un module en Python est un fichier contenant du code Python. Il peut inclure des fonctions, des classes, des variables, et m√™me des instructions ex√©cutables. Un module permet de regrouper des fonctionnalit√©s sp√©cifiques dans un fichier distinct afin de rendre le code plus r√©utilisable, organis√© et lisible.

En Python, les modules sont simplement des fichiers avec l'extension .py. Vous pouvez cr√©er votre propre module ou utiliser des modules standard fournis avec Python. Pour utiliser un module, vous devez l'importer dans votre programme avec la commande import.

> **Voir aussi:** https://peps.python.org/pep-0002/

Les fonctions permettent de regrouper des instructions pour accomplir une t√¢che sp√©cifique. Elles favorisent la r√©utilisabilit√© et l'organisation du code.

> Bilan : Les modules et fonctions permettent ainsi de cr√©er des programmes bien structur√©s, organis√©s autour de blocs logiques qui favorisent la r√©utilisation et la compr√©hension du code.

## Programmation orient√©e objet : principes de l'objet

La programmation orient√©e objet (POO) repose sur plusieurs principes fondamentaux, parmi lesquels : **polymorphisme**, **encapsulation** et **h√©ritage**. Ces concepts permettent de structurer le code de mani√®re modulaire, r√©utilisable et extensible.

### 1. Polymorphisme  
Le polymorphisme permet √† une m√™me m√©thode ou fonction d'avoir des comportements diff√©rents selon le contexte ou le type de donn√©es.  

#### Exemple concret : Syst√®me de paiement

Imaginons un syst√®me de paiement qui accepte plusieurs m√©thodes de paiement (carte bancaire, PayPal, Bitcoin). Chaque m√©thode a sa propre logique, mais toutes doivent impl√©menter une m√©thode `pay()`.

```python
class PaymentMethod:
    def pay(self, amount):
        pass

class CreditCard(PaymentMethod):
    def pay(self, amount):
        print(f"Payment of {amount} made using Credit Card.")

class PayPal(PaymentMethod):
    def pay(self, amount):
        print(f"Payment of {amount} made using PayPal.")

class Bitcoin(PaymentMethod):
    def pay(self, amount):
        print(f"Payment of {amount} made using Bitcoin.")

# Polymorphisme : utilisation de diff√©rentes m√©thodes de paiement
def process_payment(payment_method, amount):
    payment_method.pay(amount)

# Utilisation
credit_card = CreditCard()
paypal = PayPal()
bitcoin = Bitcoin()

process_payment(credit_card, 100)  # Payment of 100 made using Credit Card.
process_payment(paypal, 200)       # Payment of 200 made using PayPal.
process_payment(bitcoin, 300)      # Payment of 300 made using Bitcoin.
```

### 2. Encapsulation

L'encapsulation consiste √† restreindre l'acc√®s direct aux donn√©es internes d'une classe et √† les prot√©ger contre les modifications non contr√¥l√©es. Cela est r√©alis√© en d√©finissant des attributs priv√©s ou prot√©g√©s et en utilisant des m√©thodes d'acc√®s (getters et setters).

#### Exemple ici avec la gestion des paiements dans un SI bancaire :

```python
class BankAccount:
    def __init__(self, owner, balance, credit_limit):
        self.owner = owner
        self.__balance = balance  # Attribut priv√©
        self.__credit_limit = credit_limit  # Attribut priv√©

    # Getter pour acc√©der au solde
    def get_balance(self):
        return self.__balance

    # M√©thode pour savoir si l'utilisateur peut payer une certaine somme
    def can_pay(self, amount):
        return amount <= self.__balance + self.__credit_limit

    # D√©p√¥t d'argent
    def deposit(self, amount):
        if amount > 0:
            self.__balance += amount
        else:
            raise ValueError("Le montant doit √™tre positif.")

    # Retrait d'argent (avec v√©rification de la possibilit√© de paiement)
    def withdraw(self, amount):
        if amount <= self.__balance:
            self.__balance -= amount
        elif amount <= self.__balance + self.__credit_limit:
            # Utilisation du cr√©dit autoris√© si le solde est insuffisant
            self.__credit_limit -= (amount - self.__balance)
            self.__balance = 0
        else:
            raise ValueError("Solde insuffisant et limite de cr√©dit atteinte.")

# Utilisation
account = BankAccount("Alice", 1000, 500)  # Alice a un solde de 1000 et une limite de cr√©dit de 500

# V√©rifier si Alice peut payer
print(account.can_pay(1200))  # True, car 1000 (solde) + 500 (cr√©dit) = 1500, suffisant pour 1200
print(account.can_pay(1700))  # False, car 1000 + 500 = 1500, insuffisant pour 1700

# Retrait
account.withdraw(1200)  # Utilisation du cr√©dit de 200, il reste 100 dans le solde
print(account.can_pay(100))  # True, car 0 (solde) + 500 (cr√©dit) suffisant pour 100
```

> On remarque qu'on a pas besoin de conna√Ætre le montant du compte en banque d'alice pour r√©aliser l'op√©ration, mais que cela est fait de mani√®re intrins√®que a l'op√©ration de consommation et de "can_pay".

### 3. H√©ritage

L'h√©ritage permet de cr√©er de nouvelles classes (sous-classes) en r√©utilisant le code d'une classe existante (classe parente). Cela favorise la r√©utilisabilit√© et l'organisation du code. En Python, une sous-classe h√©rite de toutes les m√©thodes et attributs de la classe parente, mais peut aussi red√©finir des comportements sp√©cifiques.

#### Exemple avec une classe d'un site de reservation proposant plusieurs services
```python
# Classe parente : Reservation
class Reservation:
    def __init__(self, name, date, price):
        self.name = name  # Nom de la personne qui r√©serve
        self.date = date  # Date de la r√©servation
        self.price = price  # Prix de la r√©servation

    def display_info(self):
        print(f"R√©servation pour {self.name} √† la date du {self.date}. Prix: {self.price}‚Ç¨")

    def confirm(self):
        print(f"La r√©servation pour {self.name} est confirm√©e.")

# Classe enfant : HotelReservation (h√©rite de Reservation)
class HotelReservation(Reservation):
    def __init__(self, name, date, price, num_nights):
        super().__init__(name, date, price)  # Appel au constructeur de la classe parente
        self.num_nights = num_nights  # Nombre de nuits r√©serv√©es

    def display_info(self):
        super().display_info()  # Appel de la m√©thode de la classe parente
        print(f"Nombre de nuits: {self.num_nights}")

    def confirm(self):
        super().confirm()  # Appel de la m√©thode de la classe parente
        print(f"R√©servation de l'h√¥tel pour {self.num_nights} nuit(s) confirm√©e.")

# Classe enfant : FlightReservation (h√©rite de Reservation)
class FlightReservation(Reservation):
    def __init__(self, name, date, price, flight_number):
        super().__init__(name, date, price)  # Appel au constructeur de la classe parente
        self.flight_number = flight_number  # Num√©ro de vol

    def display_info(self):
        super().display_info()  # Appel de la m√©thode de la classe parente
        print(f"Num√©ro de vol: {self.flight_number}")

    def confirm(self):
        super().confirm()  # Appel de la m√©thode de la classe parente
        print(f"R√©servation du vol {self.flight_number} confirm√©e.")

# Utilisation des classes

# Cr√©ation d'une r√©servation d'h√¥tel
hotel_reservation = HotelReservation("Alice", "2023-12-25", 200, 3)
hotel_reservation.display_info()
hotel_reservation.confirm()

# Cr√©ation d'une r√©servation de vol
flight_reservation = FlightReservation("Bob", "2023-12-25", 150, "AF1234")
flight_reservation.display_info()
flight_reservation.confirm()
```

## Programmation orient√©e objet : Principes SOLID 

![](https://cdn.prod.website-files.com/65cb885e207a8d416674eca1/668fc5664209f0b439cce300_Sans%20titre-4.png)

### 1. **SRP : Principe de Responsabilit√© Unique (Single Responsibility Principle)**  
Un module logiciel (classe, fonction, etc.) ne doit avoir qu'une seule raison de changer.  
```python
# Mauvaise pratique : une seule classe g√®re plusieurs responsabilit√©s.
class Order:
    def calculate_total(self):
        pass  # Calcul du total
    def print_order(self):
        pass  # Imprime la commande
    def save_to_db(self):
        pass  # Sauvegarde dans la base de donn√©es

# Bonne pratique : chaque classe g√®re une seule responsabilit√©.
class Order:
    def calculate_total(self):
        pass

class OrderPrinter:
    def print_order(self, order):
        pass

class OrderRepository:
    def save_to_db(self, order):
        pass
```

> Cela implique donc qu'il faut s√©parer fonctionnellement les impl√©mentations entre des **couches** bien distinctes => Vues, Business_object, ...

### 2. **OCP : Principe Ouvert-Ferm√© (Open-Closed Principle)**  
Les modules logiciels doivent √™tre **ouverts** √† l‚Äôextension, mais **ferm√©s** √† la modification.  
```python
# Mauvaise pratique : modification du code existant pour ajouter un comportement.
class Discount:
    def apply_discount(self, price, discount_type):
        if discount_type == "percentage":
            return price * 0.9
        elif discount_type == "fixed":
            return price - 10

# Bonne pratique : extension via des classes d√©riv√©es.
from abc import ABC, abstractmethod

class Discount(ABC):
    @abstractmethod
    def apply_discount(self, price):
        pass

class PercentageDiscount(Discount):
    def apply_discount(self, price):
        return price * 0.9

class FixedDiscount(Discount):
    def apply_discount(self, price):
        return price - 10
```

> Cela vous permet de d√©finir autant de versions diff√©rentes par extensions plut√¥t que de cr√©er des chaines de **if**.

### 3. **LSP : Principe de Substitution de Liskov (Liskov Substitution Principle)**  
Les sous-types doivent √™tre substituables √† leurs types parents.  
=> Les enfants doivent respecter le contrat d'interface des parents.

```python
# Mauvaise pratique : la classe d√©riv√©e casse le contrat de la classe parent.
class Bird:
    def fly(self):
        pass

class Penguin(Bird):
    def fly(self):
        raise Exception("Les pingouins ne volent pas!")

# Bonne pratique : refactorisation pour respecter le contrat.
from abc import ABC, abstractmethod

class Bird(ABC):
    @abstractmethod
    def move(self):
        pass

class FlyingBird(Bird):
    def move(self):
        print("Je vole!")

class NonFlyingBird(Bird):
    def move(self):
        print("Je marche!")
```
### 4. **ISP : Principe de S√©gr√©gation des Interfaces (Interface Segregation Principle)**  
Un client ne doit pas √™tre forc√© de d√©pendre d'interfaces qu'il n'utilise pas.  
- Ce principe pr√¥ne la conception d‚Äôinterfaces sp√©cifiques √† un usage pr√©cis, √©vitant les d√©pendances inutiles.  

Il faut donc s√©parer lorsqu'il y a des d√©pendances non pertinentes pour d√©finir un objet en plusieurs sous d√©pendances.

```python
# Mauvaise pratique : une interface trop large.
class Animal:
    def eat(self):
        pass
    def fly(self):
        pass
    def swim(self):
        pass

class Dog(Animal):
    def eat(self):
        pass
    def fly(self):  # Non pertinent pour un chien.
        raise NotImplementedError()
    def swim(self):
        pass

# Bonne pratique : des interfaces sp√©cifiques.
from abc import ABC, abstractmethod

class Eater(ABC):
    @abstractmethod
    def eat(self):
        pass

class Swimmer(ABC):
    @abstractmethod
    def swim(self):
        pass

class Dog(Eater, Swimmer):
    def eat(self):
        print("Je mange!")
    def swim(self):
        print("Je nage!")
```

### 5. **DIP : Principe d'Inversion des D√©pendances (Dependency Inversion Principle)**  
Les modules de haut niveau ne doivent pas d√©pendre des modules de bas niveau.  
- Les d√©tails doivent d√©pendre des abstractions, et non l‚Äôinverse. Cela permet une s√©paration claire entre la logique m√©tier et les d√©tails d‚Äôimpl√©mentation.

```python
# Mauvaise pratique : d√©pendance directe sur une impl√©mentation.
class Database:
    def connect(self):
        print("Connexion √† la base de donn√©es...")

class UserRepository:
    def __init__(self):
        self.db = Database()
    def get_user(self, user_id):
        self.db.connect()
        print(f"R√©cup√©ration de l'utilisateur {user_id}")

# Bonne pratique : d√©pendance sur une abstraction.
from abc import ABC, abstractmethod

class Database(ABC):
    @abstractmethod
    def connect(self):
        pass

class MySQLDatabase(Database):
    def connect(self):
        print("Connexion √† MySQL...")

class UserRepository:
    def __init__(self, db: Database):
        self.db = db
    def get_user(self, user_id):
        self.db.connect()
        print(f"R√©cup√©ration de l'utilisateur {user_id}")

# Utilisation
db = MySQLDatabase()
repo = UserRepository(db)
repo.get_user(1)
```

> Il faut ici noter qu'on injecte des interfaces plut√¥t que des impl√©mentations et donc cela permet de changer l'impl√©mentation sans avoir a toucher a la classe fille

#### Importance des Principes SOLID  
Ces principes permettent :  
- Une meilleure **maintenabilit√©** : le code est plus facile √† comprendre, tester et modifier.  
- Une meilleure **√©volutivit√©** : les modifications ou extensions du logiciel n‚Äôaffectent pas ses parties stables.  

