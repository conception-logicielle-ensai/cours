---
title: üîÑ Automatisation des contr√¥les sur une base de code versionn√©e
url:  /docs/automatisation
---

## Automatisation des contr√¥les en local


### Qu'est-ce qu'un git hooks ? 

Les hooks Git sont des scripts qui s'ex√©cutent automatiquement d√®s qu'un √©v√©nement particulier se produit dans un d√©p√¥t Git. Ils vous permettent de personnaliser le comportement interne de Git et de d√©clencher des actions personnalisables √† des points cl√©s dans le cycle de vie du d√©veloppement.

### Cr√©ation d'un hook

Nous souhaitons automatiser le formatage des fichiers qui seront inclus dans notre prochain commit. Pour cela, nous allons cr√©er un hook qui s'occupera de l'auto-formatage et de la validation au moment du commit.

En supposant que vous ayez install√© les packages n√©cessaires, sinon, tapez la commande suivante :

```bash
# Commande pour installer les packages
pip install black isort flake8
```

Pour utiliser ces packages, il vous suffit de taper les commandes suivantes √† la racine de votre projet :

```bash
python -m black
python -m isort
python -m flake8
```

- **Black** : Suit les r√®gles PEP 8 par d√©faut.
- **isort** : Organise les importations dans un ordre logique.
- **Flake8** : V√©rifie la conformit√© avec PEP 8.

Pour cela, nous allons cr√©er un fichier `pre-commit` personnalis√© directement dans le dossier `.git/hooks` de votre projet.

> Voici un lien vers un tutoriel qui explique [comment cr√©er un git hook](https://www.atlassian.com/fr/git/tutorials/git-hooks).

---

### TP cr√©ation d'un hook `pre-commit`

Pour ce TP, nous allons nous concentrer sur l'utilisation de la ligne de commande.

#####  0. **Observer le dossier `.git`**

Nous allons parcourir le dossier `.git`, qui contient des informations cruciales sur la gestion des versions de notre projet. Pour cela, nous utiliserons les commandes suivantes :

```bash
# Se d√©placer dans le r√©pertoire du projet
cd chemin/vers/ton/projet
# Afficher le contenu du dossier .git
ls -la .git
# Entrer dans le dossier .git
cd .git
# Voir le contenu du dossier .git
ls
# Acc√©der au dossier objects
cd objects
# Afficher le contenu du dossier objects
ls
# Revenir au dossier .git
cd ..
# Revenir au dossier parent du projet
cd ..
```


> - **`ls`** : Affiche la liste des fichiers et des r√©pertoires.
> - **`-l`** : Affiche les d√©tails sous forme de liste (permissions, propri√©taire, taille, etc.).
> - **`-a`** : Affiche tous les fichiers, y compris ceux qui commencent par un point (`.`), qui sont normalement cach√©s.

> **`cd`** : Permet de changer de dossier.

**Sous-dossiers importants dans `.git`**

Voici quelques exemples de sous-dossiers essentiels que vous pouvez trouver dans `.git` :

- **`objects`** : Contient les objets Git (commits, arbres, blobs).
- **`refs`** : Contient les r√©f√©rences aux branches et aux tags.
- **`config`** : Fichier de configuration du d√©p√¥t Git.


##### 1. **Cr√©er ou modifier le fichier `pre-commit`**
   Acc√©dez au dossier `.git/hooks` de votre projet et cr√©ez un fichier nomm√© `pre-commit` :

   ```bash
   touch .git/hooks/pre-commit
   ```

   > `touch` est utilis√©e pour cr√©er des fichiers vides

#####  2. **Ajouter du contenu au fichier `pre-commit`**
   Ouvrez ce fichier dans un √©diteur de texte :

   ```bash
   nano .git/hooks/pre-commit
   ```

   > `nano` est un √©diteur de texte en ligne de commande.

   Ajoutez le script suivant :

   ```bash
    #!/bin/bash

    # Chemin vers Python (modifiez si n√©cessaire)
    PYTHON_BIN=$(which python3)

    # R√©cup√©rer la liste des fichiers actuellement dans l\'index (staging area)
    STAGED_FILES=$(git diff --cached --name-only --diff-filter=d | grep '\.py$')

    if [[ -z "$STAGED_FILES" ]]; then
    echo "Aucun fichier Python √† v√©rifier."
    exit 0
    fi

    echo "Ex√©cution des v√©rifications sur les fichiers ajout√©s au staging..."

    # Formatage avec Black
    echo "Formatage avec Black..."
    $PYTHON_BIN -m black $STAGED_FILES

    # Organisation des imports avec isort
    echo "Organisation des imports avec isort..."
    $PYTHON_BIN -m isort $STAGED_FILES

    # V√©rification avec Flake8
    echo "V√©rification du style avec Flake8..."
    $PYTHON_BIN -m flake8 $STAGED_FILES
    FLAKE8_STATUS=$?

    if [[ $FLAKE8_STATUS -ne 0 ]]; then
        echo "Erreur : Flake8 a d√©tect√© des probl√®mes. Commit bloqu√©."
        exit 1
    fi

    # R√©ajouter uniquement les fichiers qui √©taient dans le staging
    echo "Ajout des fichiers modifi√©s au staging..."
    git add $STAGED_FILES

    echo "Toutes les v√©rifications sont pass√©es. Commit autoris√©."
    exit 0
   ```
   > `$(...)` est utilis√© pour ex√©cuter une commande et ins√©rer son r√©sultat dans une autre commande ou une variable.
   
   > `echo` est utilis√©e pour afficher du texte ou des variables dans le terminal. 

##### 3. **Rendre le fichier ex√©cutable**
   Rendez le fichier `pre-commit` ex√©cutable avec la commande suivante :

   ```bash
   chmod +x .git/hooks/pre-commit
   ```

   > `chmod` (abr√©viation de Change Mode) est utilis√©e en ligne de commande pour modifier les permissions d'acc√®s √† des fichiers ou des r√©pertoires

##### 4. **Tester le hook**
   Essayez de committer un fichier dans votre projet pour voir si le hook est ex√©cut√© :

   ```bash
   git add .
   git commit -m "Test du hook pre-commit"
   ```

   Si des fichiers sont modifi√©s par Black ou isort, le hook les ajoutera automatiquement au staging et r√©ex√©cutera les √©tapes.

---

### Points importants

- Si un fichier ne respecte pas les r√®gles, Flake8 bloquera le commit. Vous devrez corriger les erreurs avant de r√©essayer.
- Si vous avez besoin d'une configuration sp√©cifique pour Black, isort, ou Flake8, placez les fichiers de configuration (`pyproject.toml`, `.isort.cfg`, `.flake8`) √† la racine de votre projet.

### Pour aller plus loin : le passage a Tox

Il existe un outil tr√®s adapt√© a l'agglom√©ration des scripts et environnements pythons pour l'execution de contr√¥le dans le projet : il s'agit de `tox`.

Les codes sources construit, surtout pour des languages interpr√©t√©s d√©pendent de l'environnement d'execution cible.

On peut se pr√©munir d'incompatibilit√©s et de bon fonctionnement de nos d√©veloppements dans un environnement a l'aide de gestionnaires de la configuration dans l'environnement cible.

C'est un des objectif du projet tox : https://tox.wiki/en/4.12.1/index.html

Il offre une configuration des environnements virtuels ainsi qu'une matrice de compatibilit√© python pour vous permettre de mettre en place des tests sur diff√©rentes version de python et √©galement de g√©rer des groupes de d√©pendances en fonction de d√©pendances de run / d√©pendances de test.

Il permet √©galement d'aggr√©ger les petites commandes que l'on execute dans des modules scripts, qu'on peut ensuite lancer par une simple commande.

Cela r√©pond donc aux deux probl√®mes : d√©pendances sp√©cifiques aux tests et execution automatis√©e des scripts. Mais depuis un environnement qui a le projet. (donc pour l'instant notre machine).

> Nous n'irons pas plus loin sur l'impl√©mentation, mais vous pouvez explorer cet outil, il est tr√®s utilis√© dans les projets industriels python.

**Tox en bref** : 

```
pip install tox
tox -e pytest
```

avec une configuration 
```
[tox]
env_list =py310
minversion = 4.12.1

[testenv:unittest]
description = run the unit tests with unittest
commands =
    python -m pytest ...
```

## Automatisation des contr√¥les sur des d√©pots h√©berg√©s

Les Forges Logicielles : Gitlab, Github (etc ...) proposent une infrastructure de **runners** et **executeurs** qui permettent d'√©xecuter des traitements lors d'√©v√©nements li√©s a la mise a jour, publication ou autre de votre code.

L'un des principaux usages de ces fonctionnalit√©, c'est de faire tourner des v√©rifications statiques et dynamiques de votre code. Ainsi, vous n'avez plus a penser a vos contr√¥les, ils s'executent a chaque nouveau commit par exemple et donc cela vous permet de voir appara√Ætre les bugs, les r√©gression et d'avoir des arguments objectifs pour la validation ou le rejet d'ajout du code d'un coll√®gue. 

> Cela permet √©galement l'h√©bergement de pages web construites (comme ce site web par exemple üî•).

### Github Actions, une introduction

GitHub Actions est un outil d'int√©gration et de d√©ploiement continu (CI/CD) natif √† GitHub, qui permet d‚Äôautomatiser des workflows directement dans vos d√©p√¥ts. Il repose sur trois concepts principaux :

- les Workflows : D√©finissent une suite d'actions √† ex√©cuter. Ils sont configur√©s via des fichiers YAML plac√©s dans le dossier `.github/workflows/` du projet sur github.

- les Jobs : Chaque workflow est compos√© de jobs qui s‚Äôex√©cutent dans des environnements distincts.

- les Steps : Un job est lui-m√™me d√©compos√© en une s√©quence d'√©tapes, comprenant des actions pr√©d√©finies ou personnalis√©es.

> Les traitements sont execut√©s sur des machines fournies par github, vous pouvez voir la typologie des machines ici : https://docs.github.com/en/actions/using-github-hosted-runners/using-github-hosted-runners/about-github-hosted-runners#standard-github-hosted-runners-for--private-repositories 

> **Dans le TP d'aujourd'hui et dans vos projets on privil√©giera d'utiliser une machine qui est un `ubuntu-22.04` comme votre environnement personnel.**


Le format des workflow est en **YAML**, c'est un format de fichier comme le **JSON**, le **XML** ou le **CSV**. On le retrouve sp√©cifiquement pour la configuration de fichier d'int√©gration et de configuration car il est assez *l√©ger* a la lecture : il repose comme le python sur de l'indentation.

Exemple avec un yaml "de base".

```yaml
name: Simple Python Workflow

on: [push]

jobs:
  simple-check:
    runs-on: ubuntu-22.04

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'

      - name: Run a simple Python command
        run: python --version
```

Le principe est le suivant : 
- D'une machine nue on peut executer des commandes pour lui installer ou bien lancer des commandes a partir de ce qui est d√©j√† install√© sur la machine. 

Avec en plus : des jobs d√©j√† construits par d'autres personnes c'est ce que l'on voit dans `actions/checkout@v4` `actions/setup-python@v5`

> On peut voir le code source ici pour le `actions/setup-python par exemple ici : https://github.com/actions/setup-python => https://github.com/actions/setup-python/releases/tag/v5.3.0  => https://github.com/actions/setup-python/blob/0b93645e9fea7318ecaed2b359559ac225c90a2b/src/setup-python.ts (oui c'est assez illisible mais on sait jamais)

### TP : mise en place d'un workflow simple LINT et TESTS

Mettez en place sur le projet diff√©rents yaml pour la mise en place d'actions sp√©cifiques : tests, lint

- 1 a l'aide de l'interface actions en bas a droite du projet, mettre en place une action qui lance pylint

<details><summary  class="reponse" ><b>Solution clickable partie 1 </b></summary>
<p>
- Il faut suivre l'installation mais veiller a ce que les requirements.txt soient bien install√©s, pylint n√©cessitant un environnement fonctionnel

- Il faut ajouter l'option fail-under car par d√©faut c'est un seuil tr√®s bas

```yaml
name: Pylint 

on: [push]

jobs:
  build:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        python-version: ["3.11"]
    steps:
    - uses: actions/checkout@v3
    - name: Set up Python ${{ matrix.python-version }}
      uses: actions/setup-python@v3
      with:
        python-version: ${{ matrix.python-version }}
    - name: Install Pylint
      run: |
        python -m pip install --upgrade pip
        pip install pylint 
        pip install -r requirements.txt
    - name: Analysing the code with isort
      run: |
        pylint $(git ls-files '*.py') --fail-under 5
```

</p></details>

- 2 Faire la m√™me chose pour black, isort, flake8 cette fois ci en √©ditant le fichier pylint.yaml en le renommant lint.yaml

<details><summary  class="reponse" ><b>Solution clickable partie 2 </b></summary>
<p>

```yaml
name: Lint

on: [push]

jobs:
  build:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        python-version: ["3.11"]
    steps:
    - uses: actions/checkout@v3
    - name: Set up Python ${{ matrix.python-version }}
      uses: actions/setup-python@v3
      with:
        python-version: ${{ matrix.python-version }}
    - name: Install Pylint Black Flake8 Isort
      run: |
        python -m pip install --upgrade pip
        pip install pylint black flake8 isort
    - name: Flake8
      run: |
        python -m flake8 predicat
    - name: Linting with pylint
      run: |
        pylint $(git ls-files '*.py') --fail-under 5
    - name: Formatting checks isort
      run: |
        python -m isort --profile black --check predicat
    - name: Formatting checks black
      run: 
        python -m black --check predicat
```


</p></details>

- 3 Faites un nouveau fichier tests.yaml o√π vous incorporerez les tests unitaires 

<details><summary  class="reponse" ><b>Solution clickable partie 3</b></summary>
<p>

```yaml
name: Tests

on: [push]

jobs:
  build:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        python-version: ["3.11"]
    steps:
    - uses: actions/checkout@v3
    - name: Set up Python ${{ matrix.python-version }}
      uses: actions/setup-python@v3
      with:
        python-version: ${{ matrix.python-version }}
    - name: Install Deps
      run: |
        python -m pip install --upgrade pip
        python -m pip install -r requirements.txt
    - name: Run tests
      run: |
        python -m unittest discover app/tests/


```

</p></details>


> Un projet bilan des 2 premiers cours est disponible ici : https://github.com/conception-logicielle-ensai/archi-exemple/