---
title: 🔰 Bonnes pratiques du développement et design patterns
url: "/docs/bonnes-pratiques-dev"
---

Cette partie est largement basée des concepts et exemples présentés dans le livre :

> **Refactoring**, Improving the design of existing code. Martin Fowler, Kent Beck 1999.

Ce livre présente un ensemble de problèmes que l'on peut retrouver dans une base de code et propose une résolution de ces problèmes par le respect de pratiques et de normes de développement.

## Code smells

Les code smells sont des indices dans le code qui suggèrent des problèmes potentiels, rendant le code difficile à comprendre, à maintenir ou à faire évoluer. Ils ne sont pas nécessairement des bugs, mais indiquent souvent des faiblesses dans la conception, comme des fonctions trop longues, des dépendances complexes ou des répétitions inutiles.

L'identification des code smells aide à repérer les zones du code qui pourraient bénéficier d'un refactoring.

 Je sais pas combien on en fait mais je mets ceux que je veux qu'on fasse absolument ici : 

> t'as le bouquin ici : https://dl.ebooksworld.ir/motoman/Refactoring.Improving.the.Design.of.Existing.Code.2nd.edition.www.EBooksWorld.ir.pdf

Parler en gros de ceux là: 
- Mysterious Name
- Duplicated Code
- Magic Numbers
- Long Function
- Long Parameter List
- Mutabilité des variables

> Pour aller plus loin : On retrouve différents des principaux code smells ici : https://refactoring.guru/refactoring/smells

### Magic Numbers


Le terme "magic number" désigne l'utilisation de constantes numériques non nommées dans le code source d'un programme. Cette pratique peut rendre le code difficile à comprendre et à maintenir, car elle obscurcit le sens des valeurs utilisées. En nommant explicitement toutes les constantes, on améliore la lisibilité, la compréhension et la maintenabilité du code, ce qui facilite la collaboration entre développeurs.

#### Exemple de Code avec Magic Numbers

Voici un exemple illustrant l'utilisation de magic numbers dans le calcul de valeurs extrêmes et de moyennes glissantes :

```python
import numpy as np

def extreme(data):
    # Calcul de la moyenne et de l'écart-type
    mean = np.mean(data)
    std_dev = np.std(data)
    resultat = []  # Liste pour stocker les valeurs extrêmes
    for x in data:
        if abs(x - mean) > 3 * std_dev: 
            resultat.append(x)  # Utilisation de append pour ajouter des éléments
    return resultat  # Retourne la liste des valeurs extrêmes

# Calcul de la moyenne glissante sur une fenêtre de taille 3
def moyenne_glissante(data):
    """
    Calcule une moyenne glissante sur une fenêtre de taille 3.
    Les bords où il n'y a pas assez de valeurs retournent None.
    """
    if len(data) < 3:
        return [None] * len(data)

    resultats = [None]  # Padding initial pour le bord gauche
    for i in range(1, len(data) - 1):
        moyenne = np.mean(data[i - 1:i + 2])  # Calcul de la moyenne glissante
        resultats.append(moyenne)
    resultats.append(None)  # Padding final pour le bord droit
    return resultats

# Données
data = [100, 102, 98, 97, 250, 101, 99, 102]
# Identification des valeurs extrêmes (plus de 3 écarts-types de la moyenne)
extremes = extreme(data)
print(f"Valeurs extrêmes : {extremes}")
# Calcul et affichage de la moyenne glissante
glissement = moyenne_glissante(data)
print(f"Moyenne glissante sur 3 : {glissement}")
```

#### Pourquoi Éviter les Magic Numbers ?

L'utilisation de magic numbers présente plusieurs inconvénients :

- **Manque de Clarté** : Lorsqu'un développeur lit le code, il peut se demander « Pourquoi 3 ? » pour la condition d'écart-type. Cela complique la compréhension rapide du code et nécessite des réflexions supplémentaires pour comprendre le choix de cette valeur.
  
- **Ambiguïté** : Les magic numbers peuvent être déroutants lorsqu'ils sont utilisés pour des significations différentes au sein du même morceau de code. Par exemple, deux variables différentes pourraient avoir la même valeur, créant ainsi une confusion sur leur utilisation.

- **Difficulté de Maintenance** : Modifier une valeur magique peut être source d'erreurs, car elle est souvent utilisée à plusieurs endroits. Par exemple, pour adapter la taille de la moyenne glissante de 3 à 5, un développeur pourrait remplacer toutes les occurrences de 3 par 5. Cela pourrait entraîner des erreurs, notamment si certaines portions du code, comme l'expression `[i - 1:i + 2]`, ne sont pas mises à jour.

#### Amélioration du Code

Pour éviter l'utilisation de magic numbers, il est préférable de définir des constantes nommées :

```python
import numpy as np

# Définition des constantes
TAILLE_FENETRE_GLISSANTE = 3
MULTIPLICATEUR_SEUIL = 3

def extreme(data):
    # Calcul de la moyenne et de l'écart-type
    mean = np.mean(data)
    std_dev = np.std(data)
    resultat = []  # Liste pour stocker les valeurs extrêmes
    for x in data:
        if abs(x - mean) > MULTIPLICATEUR_SEUIL * std_dev:  # Utilisation de la constante
            resultat.append(x)
    return resultat  # Retourne la liste des valeurs extrêmes

# Calcul de la moyenne glissante sur une fenêtre de taille définie
def moyenne_glissante(data):
    """
    Calcule une moyenne glissante sur une fenêtre de taille définie.
    Les bords où il n'y a pas assez de valeurs retournent None.
    """
    if len(data) < TAILLE_FENETRE_GLISSANTE:
        return [None] * len(data)

    resultats = [None]  # Padding initial pour le bord gauche
    for i in range(1, len(data) - 1):
        moyenne = np.mean(data[i - 1:i + TAILLE_FENETRE_GLISSANTE - 1])  # Utilisation de la constante
        resultats.append(moyenne)
    resultats.append(None)  # Padding final pour le bord droit
    return resultats

# Données
data = [100, 102, 98, 97, 250, 101, 99, 102]
# Identification des valeurs extrêmes (plus de 3 écarts-types de la moyenne)
extremes = extreme(data)
print(f"Valeurs extrêmes : {extremes}")
# Calcul et affichage de la moyenne glissante
glissement = moyenne_glissante(data)
print(f"Moyenne glissante sur 3 : {glissement}")
```

Dans ce code amélioré, la modification de la valeur de `TAILLE_FENETRE_GLISSANTE` ou `MULTIPLICATEUR_SEUIL` ne nécessite qu'une seule intervention, ce qui facilite la maintenance.

#### Comment Éviter les Magic Numbers ?

Pour éviter les magic numbers :

- **Utilisez des Constantes Nommées** : Déclarez les constantes en MAJUSCULES au début de vos fichiers ou fonctions. Cela facilite leur recherche et modification. Par exemple, `MULTIPLICATEUR_SEUIL = 3` peut être considéré comme une vérité statistique, donc il est peu probable qu'elle change.

- **Paramètres de Fonction** : Pour les valeurs qui peuvent nécessiter des ajustements, passez-les en paramètres de fonction. Par exemple, dans `moyenne_glissante`, cela a plus de sens de les traiter comme un paramètre, ce qui permet d'associer une valeur explicite à la fenêtre glissante.

#### Conclusion
Les problèmes liés aux magic numbers ne se limitent pas aux constantes numériques. Ce terme s'applique également à d'autres types de données. Par exemple, déclarer const string testNomUtilisateur = "Jean" est préférable à l'utilisation directe du mot "Jean" à plusieurs endroits dans le programme.

En gros dès que vous avez des string ou des nombre (entier ou flotant) écrit en dur, c'est que vous avez mal fait les chose.
Adopter des pratiques pour éviter les magic numbers permet non seulement d'améliorer la clarté et la lisibilité du code, mais aussi d'assurer une maintenance plus simple et moins sujette aux erreurs. En utilisant des constantes nommées et des paramètres de fonction, les développeurs peuvent créer un code plus robuste et plus compréhensible.


### Exercice : Magic Numbers

#### Questions
1. Combien de lignes de code doivent être modifiées pour changer la définition d'une température "basse" à moins de 18°C et plus de 20°C ?
2. Dans le code ci-dessous, retirez tous les magic numbers en les remplaçant par des constantes nommées.

#### Code
```python
class AnalyseMeteo:
    def __init__(self, temperatures, humidites):
        self.temperatures = temperatures
        self.humidites = humidites

    def obtenir_journees_chaudes(self):
        # Températures supérieures à 30°C
        return [temp for temp in self.temperatures if temp > 30]

    def verifier_humidite_acceptable(self):
        # Humidité entre 30% et 70%
        return [hum for hum in self.humidites if 30 <= hum <= 70]

    def comment_est_la_journée(self, temperature, humidite):
        # Idéal : Température entre 20°C et 25°C et humidité < 60%
        if 20 <= temperature <= 25 and humidite < 60:
            return print("La journée est idéale")
        if 20 <= temperature <= 25 and humidite > 60:
            return print("La journée a une température idéale, mais un taux d'humidité trop élevé")
        if temperature > 25 and humidite < 60:
            return print("La journée a une température trop élevée, mais un taux d'humidité idéal")
        else:
            return print("La journée n'est pas idéale")
```


## Normalisation des nommages : Introduction aux normes de nommage en Python

En Python, des normes et des conventions de nommage existent pour améliorer la lisibilité et la compréhension du code.

### 1. Nommage des fichiers et des modules

- **Convention** : Utilisez des lettres minuscules et des underscores pour séparer les mots. 
- **Exemple** : `mon_script.py`, `utils.py`

### 2. Nommage des classes

- **Convention** : Adoptez le style CamelCase pour les noms de classes, où chaque mot commence par une majuscule.
- **Exemple** : `MaClasse`, `GestionnaireDeFichiers`

### 3. Nommage des variables et des arguments de fonction

- **Convention** : Utilisez des lettres minuscules avec des underscores pour séparer les mots.
- **Exemple** : `ma_variable`, `nombre_utilisateurs`
- **Remarque** : Évitez les noms de variables ambigus ou trop génériques.

### 4. Nommage des fonctions et des méthodes

- **Convention** : Utilisez des lettres minuscules avec des underscores pour les noms de fonctions, comme pour les variables.
- **Exemple** : `calculer_somme`, `obtenir_utilisateur`
- **Remarque** : Les noms de fonctions doivent être descriptifs et indiquer clairement leur objectif.

### 5. Nommage des constantes

- **Convention** : Utilisez des lettres majuscules avec des underscores pour séparer les mots. Les constantes doivent être définies en haut du fichier ou du module.
- **Exemple** : `MAX_TAILLE`, `NOMBRE_MAXI_UTILISATEURS`

### 6. Nommage des packages et des dossiers
- **Convention** : Utilisez des lettres minuscules et évitez les underscores. 
- **Exemple** : `monpackage`, `utilitaires`

### 7. Autres bonnes pratiques

- **Utilisez des mots significatifs** : Choisissez des noms qui décrivent clairement le rôle d'une variable, d'une fonction ou d'une classe.
- **Évitez les abréviations obscures** : Les noms doivent être compréhensibles pour toute personne lisant le code.

Les fonctions et méthodes doivent être nommées en commençant par un verbe à l'infinitif, tandis que tous les autres éléments commencent par un nom.

> Il est préférable d'utiliser des noms longs et explicites plutôt que des noms courts dont la signification n'est claire qu'au moment du développement. N'oubliez pas que dans un vrai projet, vous collaborez avec d'autres personnes, mais aussi avec vous-même dans le futur, qui pourrait avoir oublié le contexte de ce bout de code.


## Patrons de conception 

Cette partie est largement basée sur les 23 design patterns présentés dans le livre : 

> Design Patterns: Elements of Reusable Object-Oriented Software (Addison-Wesley Professional Computing Series), Gamma Erich, Richard Helm, Ralph Johnson, John Vissidies, 1994


Les patrons de conception ou design patterns sont des arrangements caractéristiques logiques permettant la bonne conception de modules applicatifs logiciels en Programmation Orientée Objet. Il en existe une multitude répondant a des problématiques de réutilisabilité et d'implémentation qualitative.

> En général, on présente un patron en réponse a une problématique

### Gang of Four (GoF), ou le conseil des 23 (et non 4) 

On distingue classiquement 3 catégories des 23 design patterns classiques : 
- Les Créationnels (structurent la manière de créer des objets).
- Les Structuraux (organisent les relations entre les classes et les objets).
- Les Comportementaux (définissent comment les objets interagissent entre eux).

> Remarque : L'on retrouve une liste exhaustive des 23 ici : https://refactoring.guru/fr/design-patterns/catalog

Dans les faits, leur mise en place est spécifique a différentes situations, il est important de garder a l'esprit leur existence pour l'application dans des cas appropriés.

### Quelques exemples

Dans cette partie on retrouve différents patterns que l'on présente dans le cadre de ce cours et que l'on souhaiterait voir appliqués a différents éléments de vos logiciels.

#### 1. `Singleton` : 

Dans votre projet , l'utilitaire de connexion a la base de données était unique.

> Le design pattern singleton isole le constructeur d'une classe et en fournit une implémentation unique par le biais d'un remplacement de ce constructeur a un get d'une instance **statique**. Cela permet d'avoir une seule et unique configuration dans tout le code.

Cas d'application :
- **Logger**
- **Connecteur SGBD**
- **Gestionnaire d'authentification**
...

#### 2. `Data Transfer Object` : 

Le pattern DTO (Data Transfer Object) est utilisé pour transporter des données entre différentes couches d'une application.

> Il a été défini dans le livre : `Patterns of Enterprise Application Architecture` https://martinfowler.com/books/eaa.html

Il permet :

- De séparer les données de transfert des entités métier pour éviter de les exposer directement.
- De centraliser la validation des données avant qu'elles ne soient utilisées par les couches métier.
- D'améliorer la sécurité et la maintenabilité en contrôlant précisément ce qui est transféré et exposé.

Un DTO est généralement utilisé dans le contexte d'une API ou d'un système distribué pour sérialiser et désérialiser les données entrantes/sortantes.

Exemple dans le cadre d'une api FastAPI pour la validation d'un User avant de l'entrée dans le système :

```python
from fastapi import HTTPException, Depends, FastAPI
from typing import List

app = FastAPI()

# --- Entité métier ---
class UserDTO(BaseModel):
    username: str
    email: str
    def to_user(self):
        """Convert DTO to a plain User object."""
        return User(
            username=self.username,
            email=self.email
        )
class User:
    def __init__(self, username: str, email: str, roles: List[str]):
        self.username = username
        self.email = email
        self.roles = roles

    def __repr__(self):
        return f"User(username={self.username}, email={self.email}, roles={self.roles})"

# --- Décorateur pour vérifier les rôles ---
def requires_role(required_role: str):
    """Décorateur pour vérifier qu'un utilisateur a un rôle spécifique."""
    def decorator(method):
        def wrapper(user: User, *args, **kwargs):
            if required_role not in user.roles:
                raise HTTPException(status_code=403, detail=f"Access denied. Requires role: {required_role}")
            return method(user, *args, **kwargs)
        return wrapper
    return decorator

class UserDAO:
    def __init__(self, database:Database):
        self.database = database
    def get_user(self,user:User):
        return self.db_session.query(User).filter(User.id == user.username).first()
# --- Méthode décorée ---
class UserService:
    def __init__(self, user_dao:UserDAO):
        self.user_dao = user_dao
    @staticmethod
    @requires_role("admin")
    def peut_se_connecter(user: User):
        """Vérifie si l'utilisateur peut se connecter (uniquement pour les administrateurs)."""
        return {"message": f"User {user.username} can connect as admin."}
    def fetch_roles(self,user:User):
        updated_user = self.user_dao.fetch_roles(user)
        return updated_user 
# --- API Endpoint ---
@app.post("/connect")
def connect(user_dto: UserDTO = Depends(lambda: UserDto(username="JohnDoe", email="johndoe@example.com"))):
    """
    Endpoint qui utilise la méthode `peut_se_connecter` pour vérifier si l'utilisateur peut accéder.
    Un utilisateur avec le rôle "admin" est nécessaire.
    """
    return UserService.peut_se_connecter(userDTO.to_user())
```

L'avantage est l'isolation des données d'entrée et de sortie du système et de ne pas demander la saisie intégrale du champ user alors que l'on a seulement besoin d'un identifiant ou identifiant et mail par exemple.

> ️‍🔥️‍🔥️‍🔥 Si l'on doit faire évoluer, on peut faire évoluer seulement l'entrée, ou seulement l'objet a l'intérieur du système. ️‍🔥️‍🔥️‍🔥

