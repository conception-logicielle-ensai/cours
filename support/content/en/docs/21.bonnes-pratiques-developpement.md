---
title: ğŸ”° Bonnes pratiques du dÃ©veloppement et design patterns
url: "/docs/bonnes-pratiques-dev"
---

Cette partie est largement basÃ©e des concepts et exemples prÃ©sentÃ©s dans le livre :

> **Refactoring**, Improving the design of existing code. Martin Fowler, Kent Beck 1999.

Ce livre prÃ©sente un ensemble de problÃ¨mes que l'on peut retrouver dans une base de code et propose une rÃ©solution de ces problÃ¨mes par le respect de pratiques et de normes de dÃ©veloppement.

## Code smells

Les code smells sont des indices dans le code qui suggÃ¨rent des problÃ¨mes potentiels, rendant le code difficile Ã  comprendre, Ã  maintenir ou Ã  faire Ã©voluer. Ils ne sont pas nÃ©cessairement des bugs, mais indiquent souvent des faiblesses dans la conception, comme des fonctions trop longues, des dÃ©pendances complexes ou des rÃ©pÃ©titions inutiles.

L'identification des code smells aide Ã  repÃ©rer les zones du code qui pourraient bÃ©nÃ©ficier d'un refactoring.

> Pour aller plus loin : On retrouve diffÃ©rents des principaux code smells ici : https://refactoring.guru/refactoring/smells

## Magic Numbers


Le terme "magic number" dÃ©signe l'utilisation de constantes numÃ©riques non nommÃ©es dans le code source d'un programme. Cette pratique peut rendre le code difficile Ã  comprendre et Ã  maintenir, car elle obscurcit le sens des valeurs utilisÃ©es. En nommant explicitement toutes les constantes, on amÃ©liore la lisibilitÃ©, la comprÃ©hension et la maintenabilitÃ© du code, ce qui facilite la collaboration entre dÃ©veloppeurs.

#### Exemple de Code avec Magic Numbers

Voici un exemple illustrant l'utilisation de magic numbers dans le calcul de valeurs extrÃªmes et de moyennes glissantes :

```python
import numpy as np

def extreme(data):
    # Calcul de la moyenne et de l'Ã©cart-type
    mean = np.mean(data)
    std_dev = np.std(data)
    resultat = []  # Liste pour stocker les valeurs extrÃªmes
    for x in data:
        if abs(x - mean) > 3 * std_dev: 
            resultat.append(x)  # Utilisation de append pour ajouter des Ã©lÃ©ments
    return resultat  # Retourne la liste des valeurs extrÃªmes

# Calcul de la moyenne glissante sur une fenÃªtre de taille 3
def moyenne_glissante(data):
    """
    Calcule une moyenne glissante sur une fenÃªtre de taille 3.
    Les bords oÃ¹ il n'y a pas assez de valeurs retournent None.
    """
    if len(data) < 3:
        return [None] * len(data)

    resultats = [None]  # Padding initial pour le bord gauche
    for i in range(1, len(data) - 1):
        moyenne = np.mean(data[i - 1:i + 2])  # Calcul de la moyenne glissante
        resultats.append(moyenne)
    resultats.append(None)  # Padding final pour le bord droit
    return resultats

# DonnÃ©es
data = [100, 102, 98, 97, 250, 101, 99, 102]
# Identification des valeurs extrÃªmes (plus de 3 Ã©carts-types de la moyenne)
extremes = extreme(data)
print(f"Valeurs extrÃªmes : {extremes}")
# Calcul et affichage de la moyenne glissante
glissement = moyenne_glissante(data)
print(f"Moyenne glissante sur 3 : {glissement}")
```

<details><summary><b>Pourquoi Ã©viter les Magic Numbers ? (Cliquez ici pour en savoir plus)</b></summary>
<p>

<h3>Pourquoi Ã‰viter les Magic Numbers ?</h3>

L'utilisation de **magic numbers** dans le code prÃ©sente plusieurs inconvÃ©nients majeurs :

- **Manque de clartÃ©** : Lorsqu'un dÃ©veloppeur lit le code, il peut se demander : Â« Pourquoi cette valeur ? Â». Par exemple, une condition impliquant la valeur `3` pour un Ã©cart-type peut sembler arbitraire. Cela complique la comprÃ©hension rapide du code et nÃ©cessite une rÃ©flexion supplÃ©mentaire pour deviner la signification de la valeur.

- **AmbiguÃ¯tÃ©** : Les magic numbers peuvent prÃªter Ã  confusion lorsqu'ils sont utilisÃ©s pour reprÃ©senter des concepts diffÃ©rents dans le mÃªme programme. Par exemple, si deux variables distinctes partagent la mÃªme valeur, cela complique l'identification de leur rÃ´le respectif.

- **DifficultÃ© de maintenance** : Modifier une valeur magique peut entraÃ®ner des erreurs, car cette valeur est souvent utilisÃ©e Ã  plusieurs endroits. Par exemple, pour passer d'une taille de moyenne glissante de `3` Ã  `5`, un dÃ©veloppeur pourrait remplacer toutes les occurrences de `3` par `5`. Cela risque d'introduire des bugs, notamment si certaines parties du code, comme une expression du type `[i - 1:i + 2]`, ne sont pas correctement adaptÃ©es.

</p>
</details>


#### AmÃ©lioration du Code

Pour Ã©viter l'utilisation de magic numbers, il est prÃ©fÃ©rable de dÃ©finir des constantes nommÃ©es :

```python
import numpy as np

# DÃ©finition des constantes
TAILLE_FENETRE_GLISSANTE = 3
MULTIPLICATEUR_SEUIL = 3

def extreme(data):
    # Calcul de la moyenne et de l'Ã©cart-type
    mean = np.mean(data)
    std_dev = np.std(data)
    resultat = []  # Liste pour stocker les valeurs extrÃªmes
    for x in data:
        if abs(x - mean) > MULTIPLICATEUR_SEUIL * std_dev:  # Utilisation de la constante
            resultat.append(x)
    return resultat  # Retourne la liste des valeurs extrÃªmes

# Calcul de la moyenne glissante sur une fenÃªtre de taille dÃ©finie
def moyenne_glissante(data):
    """
    Calcule une moyenne glissante sur une fenÃªtre de taille dÃ©finie.
    Les bords oÃ¹ il n'y a pas assez de valeurs retournent None.
    """
    if len(data) < TAILLE_FENETRE_GLISSANTE:
        return [None] * len(data)

    resultats = [None]  # Padding initial pour le bord gauche
    for i in range(1, len(data) - 1):
        moyenne = np.mean(data[i - 1:i + TAILLE_FENETRE_GLISSANTE - 1])  # Utilisation de la constante
        resultats.append(moyenne)
    resultats.append(None)  # Padding final pour le bord droit
    return resultats

# DonnÃ©es
data = [100, 102, 98, 97, 250, 101, 99, 102]
# Identification des valeurs extrÃªmes (plus de 3 Ã©carts-types de la moyenne)
extremes = extreme(data)
print(f"Valeurs extrÃªmes : {extremes}")
# Calcul et affichage de la moyenne glissante
glissement = moyenne_glissante(data)
print(f"Moyenne glissante sur 3 : {glissement}")
```

Dans ce code amÃ©liorÃ©, la modification de la valeur de `TAILLE_FENETRE_GLISSANTE` ou `MULTIPLICATEUR_SEUIL` ne nÃ©cessite qu'une seule intervention, ce qui facilite la maintenance.

#### Comment Ã‰viter les Magic Numbers ?

Pour Ã©viter les magic numbers :

- **Utilisez des Constantes NommÃ©es** : DÃ©clarez les constantes en MAJUSCULES au dÃ©but de vos fichiers ou fonctions. Cela facilite leur recherche et modification. Par exemple, `MULTIPLICATEUR_SEUIL = 3` peut Ãªtre considÃ©rÃ© comme une vÃ©ritÃ© statistique, donc il est peu probable qu'elle change.

- **ParamÃ¨tres de Fonction** : Pour les valeurs qui peuvent nÃ©cessiter des ajustements, passez-les en paramÃ¨tres de fonction. Par exemple, dans `moyenne_glissante`, cela a plus de sens de les traiter comme un paramÃ¨tre, ce qui permet d'associer une valeur explicite Ã  la fenÃªtre glissante.


Les problÃ¨mes liÃ©s aux magic numbers ne se limitent pas aux constantes numÃ©riques. Ce terme s'applique Ã©galement Ã  d'autres types de donnÃ©es. Par exemple, dÃ©clarer const string testNomUtilisateur = "Jean" est prÃ©fÃ©rable Ã  l'utilisation directe du mot "Jean" Ã  plusieurs endroits dans le programme.

> En gros dÃ¨s que vous avez des string ou des nombre (entier ou flotant) Ã©crit en dur, c'est que vous avez mal fait les chose.

## Normalisation des nommages : Introduction aux normes de nommage en Python

Des normes et des conventions de nommage existent pour amÃ©liorer la lisibilitÃ©, la maintenabilitÃ© et la comprÃ©hension du code. Chaque langage a ses propres normes et conventions, adaptÃ©es Ã  ses particularitÃ©s. 

Par exemple : 
- En **Python**, les variables sont gÃ©nÃ©ralement nommÃ©es en `snake_case`.
- En **Java**, on prÃ©fÃ¨re le `camelCase` pour les noms de variables et de mÃ©thodes.

Les conventions de codage en Python sont dÃ©finies dans la [PEP 8](https://peps.python.org/pep-0008/), tandis que celles de Java sont dÃ©crites dans le document officiel [Code Conventions for the Java Programming Language](https://www.oracle.com/java/technologies/javase/codeconventions-contents.html).

Nous vous encourageons vivement Ã  consulter ces ressources pour dÃ©couvrir davantage dâ€™exemples prÃ©cis et des explications dÃ©taillÃ©es sur ces conventions. Leur respect permet de garantir un code clair, cohÃ©rent et facilement comprÃ©hensible, notamment dans un contexte de collaboration.


#### 1. Nommage des fichiers et des modules

- **Convention** : Utilisez des lettres minuscules et des underscores pour sÃ©parer les mots. 
- **Exemple** : `mon_script.py`, `utils.py`

### 2. Nommage des classes

- **Convention** : Adoptez le style PascalCase pour les noms de classes, oÃ¹ chaque mot commence par une majuscule.
- **Exemple** : `MaClasse`, `GestionnaireDeFichiers`

### 3. Nommage des variables et des arguments de fonction

- **Convention** : Utilisez des lettres minuscules avec des underscores pour sÃ©parer les mots.
- **Exemple** : `ma_variable`, `nombre_utilisateurs`
- **Remarque** : Ã‰vitez les noms de variables ambigus ou trop gÃ©nÃ©riques.

### 4. Nommage des fonctions et des mÃ©thodes

- **Convention** : Utilisez des lettres minuscules avec des underscores pour les noms de fonctions, comme pour les variables.
- **Exemple** : `calculer_somme`, `obtenir_utilisateur`
- **Remarque** : Les noms de fonctions doivent Ãªtre descriptifs et indiquer clairement leur objectif.

### 5. Nommage des constantes

- **Convention** : Utilisez des lettres majuscules avec des underscores pour sÃ©parer les mots. Les constantes doivent Ãªtre dÃ©finies en haut du fichier ou du module.
- **Exemple** : `MAX_TAILLE`, `NOMBRE_MAXI_UTILISATEURS`

### 6. Nommage des packages et des dossiers
- **Convention** : Utilisez des lettres minuscules et Ã©vitez les underscores. 
- **Exemple** : `monpackage`, `utilitaires`

### 7. Autres bonnes pratiques

- **Utilisez des mots significatifs** : Choisissez des noms qui dÃ©crivent clairement le rÃ´le d'une variable, d'une fonction ou d'une classe.
- **Ã‰vitez les abrÃ©viations obscures** : Les noms doivent Ãªtre comprÃ©hensibles pour toute personne lisant le code.

Les fonctions et mÃ©thodes doivent Ãªtre nommÃ©es en commenÃ§ant par un verbe Ã  l'infinitif, tandis que tous les autres Ã©lÃ©ments commencent par un nom.

> Il est prÃ©fÃ©rable d'utiliser des noms longs et explicites plutÃ´t que des noms courts dont la signification n'est claire qu'au moment du dÃ©veloppement. N'oubliez pas que dans un vrai projet, vous collaborez avec d'autres personnes, mais aussi avec vous-mÃªme dans le futur, qui pourrait avoir oubliÃ© le contexte de ce bout de code.


## Patrons de conception 

Cette partie est largement basÃ©e sur les 23 design patterns prÃ©sentÃ©s dans le livre : 

> Design Patterns: Elements of Reusable Object-Oriented Software (Addison-Wesley Professional Computing Series), Gamma Erich, Richard Helm, Ralph Johnson, John Vissidies, 1994


Les patrons de conception ou design patterns sont des arrangements caractÃ©ristiques logiques permettant la bonne conception de modules applicatifs logiciels en Programmation OrientÃ©e Objet. Il en existe une multitude rÃ©pondant a des problÃ©matiques de rÃ©utilisabilitÃ© et d'implÃ©mentation qualitative.

> En gÃ©nÃ©ral, on prÃ©sente un patron en rÃ©ponse a une problÃ©matique

### Gang of Four (GoF), ou le conseil des 23 (et non 4) 

On distingue classiquement 3 catÃ©gories des 23 design patterns classiques : 
- Les CrÃ©ationnels (structurent la maniÃ¨re de crÃ©er des objets).
- Les Structuraux (organisent les relations entre les classes et les objets).
- Les Comportementaux (dÃ©finissent comment les objets interagissent entre eux).

> Remarque : L'on retrouve une liste exhaustive des 23 ici : https://refactoring.guru/fr/design-patterns/catalog

Dans les faits, leur mise en place est spÃ©cifique a diffÃ©rentes situations, il est important de garder a l'esprit leur existence pour l'application dans des cas appropriÃ©s.

### Quelques exemples

Dans cette partie on retrouve diffÃ©rents patterns que l'on prÃ©sente dans le cadre de ce cours et que l'on souhaiterait voir appliquÃ©s a diffÃ©rents Ã©lÃ©ments de vos logiciels.

#### 1. `Singleton` : 

Dans votre projet , l'utilitaire de connexion a la base de donnÃ©es Ã©tait unique.

> Le design pattern singleton isole le constructeur d'une classe et en fournit une implÃ©mentation unique par le biais d'un remplacement de ce constructeur a un get d'une instance **statique**. Cela permet d'avoir une seule et unique configuration dans tout le code.

Cas d'application :
- **Logger**
- **Connecteur SGBD**
- **Gestionnaire d'authentification**
...

#### 2. `Data Transfer Object` : 

Le pattern DTO (Data Transfer Object) est utilisÃ© pour transporter des donnÃ©es entre diffÃ©rentes couches d'une application.

> Il a Ã©tÃ© dÃ©fini dans le livre : `Patterns of Enterprise Application Architecture` https://martinfowler.com/books/eaa.html

Il permet :

- De sÃ©parer les donnÃ©es de transfert des entitÃ©s mÃ©tier pour Ã©viter de les exposer directement.
- De centraliser la validation des donnÃ©es avant qu'elles ne soient utilisÃ©es par les couches mÃ©tier.
- D'amÃ©liorer la sÃ©curitÃ© et la maintenabilitÃ© en contrÃ´lant prÃ©cisÃ©ment ce qui est transfÃ©rÃ© et exposÃ©.

Un DTO est gÃ©nÃ©ralement utilisÃ© dans le contexte d'une API ou d'un systÃ¨me distribuÃ© pour sÃ©rialiser et dÃ©sÃ©rialiser les donnÃ©es entrantes/sortantes.

Exemple dans le cadre d'une api FastAPI pour la validation d'un User avant de l'entrÃ©e dans le systÃ¨me :

```python
from fastapi import HTTPException, Depends, FastAPI
from typing import List

app = FastAPI()

# --- EntitÃ© mÃ©tier ---
class UserDTO(BaseModel):
    username: str
    email: str
    def to_user(self):
        """Convert DTO to a plain User object."""
        return User(
            username=self.username,
            email=self.email
        )
class User:
    def __init__(self, username: str, email: str, roles: List[str]):
        self.username = username
        self.email = email
        self.roles = roles

    def __repr__(self):
        return f"User(username={self.username}, email={self.email}, roles={self.roles})"

# --- DÃ©corateur pour vÃ©rifier les rÃ´les ---
def requires_role(required_role: str):
    """DÃ©corateur pour vÃ©rifier qu'un utilisateur a un rÃ´le spÃ©cifique."""
    def decorator(method):
        def wrapper(user: User, *args, **kwargs):
            if required_role not in user.roles:
                raise HTTPException(status_code=403, detail=f"Access denied. Requires role: {required_role}")
            return method(user, *args, **kwargs)
        return wrapper
    return decorator

class UserDAO:
    def __init__(self, database:Database):
        self.database = database
    def get_user(self,user:User):
        return self.db_session.query(User).filter(User.id == user.username).first()
# --- MÃ©thode dÃ©corÃ©e ---
class UserService:
    def __init__(self, user_dao:UserDAO):
        self.user_dao = user_dao
    @staticmethod
    @requires_role("admin")
    def peut_se_connecter(user: User):
        """VÃ©rifie si l'utilisateur peut se connecter (uniquement pour les administrateurs)."""
        return {"message": f"User {user.username} can connect as admin."}
    def fetch_roles(self,user:User):
        updated_user = self.user_dao.fetch_roles(user)
        return updated_user 
# --- API Endpoint ---
@app.post("/connect")
def connect(user_dto: UserDTO = Depends(lambda: UserDto(username="JohnDoe", email="johndoe@example.com"))):
    """
    Endpoint qui utilise la mÃ©thode `peut_se_connecter` pour vÃ©rifier si l'utilisateur peut accÃ©der.
    Un utilisateur avec le rÃ´le "admin" est nÃ©cessaire.
    """
    return UserService.peut_se_connecter(userDTO.to_user())
```

L'avantage est l'isolation des donnÃ©es d'entrÃ©e et de sortie du systÃ¨me et de ne pas demander la saisie intÃ©grale du champ user alors que l'on a seulement besoin d'un identifiant ou identifiant et mail par exemple.

> ï¸â€ğŸ”¥ï¸â€ğŸ”¥ï¸â€ğŸ”¥ Si l'on doit faire Ã©voluer, on peut faire Ã©voluer seulement l'entrÃ©e, ou seulement l'objet a l'intÃ©rieur du systÃ¨me. ï¸â€ğŸ”¥ï¸â€ğŸ”¥ï¸â€ğŸ”¥

