---
title: üî∞ Bonnes pratiques du d√©veloppement et design patterns
url: "/docs/bonnes-pratiques-dev"
---

Cette partie est largement bas√©e des concepts et exemples pr√©sent√©s dans le livre :

> **Refactoring**, Improving the design of existing code. Martin Fowler, Kent Beck 1999.

Ce livre pr√©sente un ensemble de probl√®mes que l'on peut retrouver dans une base de code et propose une r√©solution de ces probl√®mes par le respect de pratiques et de normes de d√©veloppement.

Les exemples pr√©sent√©s dans le cours seront disponibles ici : https://github.com/conception-logicielle-ensai/exemples-cours2

## Code smells

Les code smells sont des indices dans le code qui sugg√®rent des probl√®mes potentiels, rendant le code difficile √† comprendre, √† maintenir ou √† faire √©voluer. Ils ne sont pas n√©cessairement des bugs, mais indiquent souvent des faiblesses dans la conception, comme des fonctions trop longues, des d√©pendances complexes ou des r√©p√©titions inutiles.

L'identification des code smells aide √† rep√©rer les zones du code qui pourraient b√©n√©ficier d'un refactoring.

> Pour aller plus loin : On retrouve diff√©rents des principaux code smells ici : https://refactoring.guru/refactoring/smells

### Magic Numbers

Le terme "magic number" d√©signe l'utilisation de constantes num√©riques non nomm√©es dans le code source d'un programme. Cette pratique peut rendre le code difficile √† comprendre et √† maintenir, car elle obscurcit le sens des valeurs utilis√©es. En nommant explicitement toutes les constantes, on am√©liore la lisibilit√©, la compr√©hension et la maintenabilit√© du code, ce qui facilite la collaboration entre d√©veloppeurs.

#### Exemple de Code avec Magic Numbers

Voici un exemple illustrant l'utilisation de magic numbers dans le calcul de valeurs extr√™mes et de moyennes glissantes :

```python
import numpy as np

def extreme(data):
    # Calcul de la moyenne et de l'√©cart-type
    mean = np.mean(data)
    std_dev = np.std(data)
    resultat = []  # Liste pour stocker les valeurs extr√™mes
    for x in data:
        if abs(x - mean) > 3 * std_dev: 
            resultat.append(x)  # Utilisation de append pour ajouter des √©l√©ments
    return resultat  # Retourne la liste des valeurs extr√™mes

# Calcul de la moyenne glissante sur une fen√™tre de taille 3
def moyenne_glissante(data):
    """
    Calcule une moyenne glissante sur une fen√™tre de taille 3.
    Les bords o√π il n'y a pas assez de valeurs retournent None.
    """
    if len(data) < 3:
        return [None] * len(data)

    resultats = [None]  # Padding initial pour le bord gauche
    for i in range(1, len(data) - 1):
        moyenne = np.mean(data[i - 1:i + 2])  # Calcul de la moyenne glissante
        resultats.append(moyenne)
    resultats.append(None)  # Padding final pour le bord droit
    return resultats

# Donn√©es
data = [100, 102, 98, 97, 250, 101, 99, 102]
# Identification des valeurs extr√™mes (plus de 3 √©carts-types de la moyenne)
extremes = extreme(data)
print(f"Valeurs extr√™mes : {extremes}")
# Calcul et affichage de la moyenne glissante
glissement = moyenne_glissante(data)
print(f"Moyenne glissante sur 3 : {glissement}")
```

<details><summary><b>Pourquoi √©viter les Magic Numbers ? (Cliquez ici pour en savoir plus)</b></summary>
<p>

<h3>Pourquoi √âviter les Magic Numbers ?</h3>

L'utilisation de **magic numbers** dans le code pr√©sente plusieurs inconv√©nients majeurs :

- **Manque de clart√©** : Lorsqu'un d√©veloppeur lit le code, il peut se demander : ¬´ Pourquoi cette valeur ? ¬ª. Par exemple, une condition impliquant la valeur `3` pour un √©cart-type peut sembler arbitraire. Cela complique la compr√©hension rapide du code et n√©cessite une r√©flexion suppl√©mentaire pour deviner la signification de la valeur.

- **Ambigu√Øt√©** : Les magic numbers peuvent pr√™ter √† confusion lorsqu'ils sont utilis√©s pour repr√©senter des concepts diff√©rents dans le m√™me programme. Par exemple, si deux variables distinctes partagent la m√™me valeur, cela complique l'identification de leur r√¥le respectif.

- **Difficult√© de maintenance** : Modifier une valeur magique peut entra√Æner des erreurs, car cette valeur est souvent utilis√©e √† plusieurs endroits. Par exemple, pour passer d'une taille de moyenne glissante de `3` √† `5`, un d√©veloppeur pourrait remplacer toutes les occurrences de `3` par `5`. Cela risque d'introduire des bugs, notamment si certaines parties du code, comme une expression du type `[i - 1:i + 2]`, ne sont pas correctement adapt√©es.

</p>
</details>


#### Am√©lioration du Code

Pour √©viter l'utilisation de magic numbers, il est pr√©f√©rable de d√©finir des constantes nomm√©es :

```python
import numpy as np

# D√©finition des constantes
TAILLE_FENETRE_GLISSANTE = 3
MULTIPLICATEUR_SEUIL = 3

def extreme(data):
    # Calcul de la moyenne et de l'√©cart-type
    mean = np.mean(data)
    std_dev = np.std(data)
    resultat = []  # Liste pour stocker les valeurs extr√™mes
    for x in data:
        if abs(x - mean) > MULTIPLICATEUR_SEUIL * std_dev:  # Utilisation de la constante
            resultat.append(x)
    return resultat  # Retourne la liste des valeurs extr√™mes

# Calcul de la moyenne glissante sur une fen√™tre de taille d√©finie
def moyenne_glissante(data):
    """
    Calcule une moyenne glissante sur une fen√™tre de taille d√©finie.
    Les bords o√π il n'y a pas assez de valeurs retournent None.
    """
    if len(data) < TAILLE_FENETRE_GLISSANTE:
        return [None] * len(data)

    resultats = [None]  # Padding initial pour le bord gauche
    for i in range(1, len(data) - 1):
        moyenne = np.mean(data[i - 1:i + TAILLE_FENETRE_GLISSANTE - 1])  # Utilisation de la constante
        resultats.append(moyenne)
    resultats.append(None)  # Padding final pour le bord droit
    return resultats

# Donn√©es
data = [100, 102, 98, 97, 250, 101, 99, 102]
# Identification des valeurs extr√™mes (plus de 3 √©carts-types de la moyenne)
extremes = extreme(data)
print(f"Valeurs extr√™mes : {extremes}")
# Calcul et affichage de la moyenne glissante
glissement = moyenne_glissante(data)
print(f"Moyenne glissante sur 3 : {glissement}")
```

Dans ce code am√©lior√©, la modification de la valeur de `TAILLE_FENETRE_GLISSANTE` ou `MULTIPLICATEUR_SEUIL` ne n√©cessite qu'une seule intervention, ce qui facilite la maintenance.

#### Comment √âviter les Magic Numbers ?

Pour √©viter les magic numbers :

- **Utilisez des Constantes Nomm√©es** : D√©clarez les constantes en MAJUSCULES au d√©but de vos fichiers ou fonctions. Cela facilite leur recherche et modification. Par exemple, `MULTIPLICATEUR_SEUIL = 3` peut √™tre consid√©r√© comme une v√©rit√© statistique, donc il est peu probable qu'elle change.

- **Param√®tres de Fonction** : Pour les valeurs qui peuvent n√©cessiter des ajustements, passez-les en param√®tres de fonction. Par exemple, dans `moyenne_glissante`, cela a plus de sens de les traiter comme un param√®tre, ce qui permet d'associer une valeur explicite √† la fen√™tre glissante.


Les probl√®mes li√©s aux magic numbers ne se limitent pas aux constantes num√©riques. Ce terme s'applique √©galement √† d'autres types de donn√©es. Par exemple, d√©clarer const string testNomUtilisateur = "Jean" est pr√©f√©rable √† l'utilisation directe du mot "Jean" √† plusieurs endroits dans le programme.

> En gros d√®s que vous avez des string ou des nombre (entier ou flotant) √©crit en dur, c'est que vous avez mal fait les chose.

### Code Dupliqu√©

Le code dupliqu√© est un probl√®me fr√©quent qui peut rendre votre programme plus difficile √† maintenir. Chaque fois que vous dupliquez des structures similaires dans votre code, vous introduisez un risque d'incoh√©rence. Si vous devez modifier une de ces copies, vous devez vous assurer que toutes les autres sont mises √† jour en cons√©quence. Cela augmente la probabilit√© d'erreurs et complique la lecture et l'√©volution du code. La solution consiste √† unifier ces duplications en extrayant les parties communes.

---

#### **1. Si le code dupliqu√© se trouve dans la m√™me classe**

Code avec des lignes dupliqu√©es :

```python
class Calculateur:
    def calculer_area_rectangle(self, largeur, hauteur):
        print("L'aire d'un rectangle est largeur * hauteur")
        return largeur * hauteur

    def calculer_area_carre(self, cote):
        print("L'aire d'un carr√© est cote * cote")
        return cote * cote
```

Dans cet exemple, la logique de multiplication est r√©p√©t√©e dans les deux m√©thodes. Pour √©viter cette duplication, nous pouvons extraire cette logique dans une m√©thode utilitaire.

Code mutualis√© :

```python
class Calculateur:
    def multiplier(self, a, b):
        return a * b  # M√©thode extraite pour √©viter la duplication

    def calculer_area_rectangle(self, largeur, hauteur):
        print("L'aire d'un rectangle est largeur * hauteur")
        return self.multiplier(largeur, hauteur)

    def calculer_area_carre(self, cote):
        print("L'aire d'un carr√© est cote * cote")
        return self.multiplier(cote, cote)
```

#### **2. Si le code dupliqu√© se trouve dans des sous-classes**

Code avec des lignes dupliqu√©es :

```python
class Forme:
    def area(self):
        pass  # M√©thode √† impl√©menter dans les sous-classes

class Rectangle(Forme):
    def __init__(self, largeur, hauteur):
        self.largeur = largeur
        self.hauteur = hauteur

    def area(self):
        print("L'aire d'un rectangle est largeur * hauteur")
        return self.largeur * self.hauteur

class Carre(Forme):
    def __init__(self, cote):
        self.cote = cote

    def area(self):
        print("L'aire d'un carr√© est cote * cote")
        return self.cote * self.cote
```

Ici, la logique de multiplication est dupliqu√©e dans les m√©thodes `area` de `Rectangle` et `Carre`. Pour √©viter cette duplication, nous pouvons utiliser la **m√©thode Pull Up**, qui consiste √† d√©placer le code commun dans la classe de base.

Code mutualis√© avec la m√©thode Pull Up :

```python
class Forme:
    def multiplier(self, a, b):
        return a * b  # M√©thode partag√©e pour √©viter la duplication

    def area(self):
        pass  # M√©thode g√©n√©rique √† sp√©cialiser dans les sous-classes

class Rectangle(Forme):
    def __init__(self, largeur, hauteur):
        self.largeur = largeur
        self.hauteur = hauteur

    def area(self):
        print("L'aire d'un rectangle est largeur * hauteur")
        return self.multiplier(self.largeur, self.hauteur)

class Carre(Forme):
    def __init__(self, cote):
        self.cote = cote

    def area(self):
        print("L'aire d'un carr√© est cote * cote")
        return self.multiplier(self.cote, self.cote)
```

---

Le refactoring est un processus it√©ratif : commencez par des petits changements, testez r√©guli√®rement et continuez √† am√©liorer le code progressivement.

### Fonctions trop longues

Dans la programmation, il est souvent observ√© qu'une fonction trop longue devient difficile √† comprendre. Dans le pass√©, les anciens langages de programmation avaient un inconv√©nient : appeler une sous-fonction √©tait co√ªteux en termes de performance, ce qui dissuadait les d√©veloppeurs d‚Äôutiliser des petites fonctions. Cependant, avec les langages modernes, ce co√ªt est presque inexistant lorsqu‚Äôon reste dans le m√™me processus.

Aujourd'hui, la v√©ritable contrainte li√©e aux petites fonctions r√©side dans le fait qu'elles demandent parfois un effort suppl√©mentaire √† ceux qui lisent le code, car il faut ouvrir chaque fonction pour comprendre son r√¥le. Heureusement, les outils de d√©veloppement modernes nous simplifient la t√¢che : on peut naviguer facilement vers la d√©finition d'une fonction ou afficher son contenu d'un simple clic.

Le v√©ritable avantage des petites fonctions, c'est leur nom. Un nom clair et pr√©cis permet souvent de comprendre rapidement ce que fait la fonction, sans m√™me avoir besoin d'en lire le contenu.

Prenons un exemple de fonction qui calcule le total d'une commande :

```java
public double calculerTotalCommande(List<Article> articles) {
    double total = 0;
    for (Article article : articles) {
        if (article.isEnPromotion()) {
            total += article.getPrix() * 0.9; // Remise de 10%
            if (article.getQuantite() > 5) {
                total += article.getPrix() * 0.05; // Remise suppl√©mentaire pour les gros achats
            }
        } else {
            total += article.getPrix();
        }
    }
    return total;
}
```

Ici, un bloc de code qui est accompagn√© d‚Äôun commentaire peut √™tre remplac√© par une m√©thode dont le nom r√©sume cette explication. M√™me une simple ligne de code peut justifier son extraction si elle n√©cessite un √©claircissement. Les conditions et les boucles nous donnent √©galement des pistes pour effectuer cette extraction. Par exemple, un gros switch peut √™tre divis√© en appels de fonctions individuelles, et si plusieurs switch utilisent les m√™mes conditions, on peut appliquer le polymorphisme pour am√©liorer la lisibilit√©.

Pour les boucles, il est √©galement judicieux d'extraire la boucle et son contenu dans une m√©thode s√©par√©e. Si vous avez du mal √† nommer une boucle extraite, cela peut indiquer qu'elle r√©alise deux t√¢ches diff√©rentes. Dans ce cas, n‚Äôh√©sitez pas √† diviser les boucles pour isoler les diff√©rentes t√¢ches.

Voici comment nous pourrions refactoriser la fonction pour la rendre plus lisible :

```java
public double calculerTotalCommande(List<Article> articles) {
    double total = 0;
    for (Article article : articles) {
        total += calculerPrixArticle(article);
    }
    return total;
}

private double calculerPrixArticle(Article article) {
    double prixFinal = article.getPrix();
    if (article.isEnPromotion()) {
        prixFinal *= 0.9; // Remise de 10%
        prixFinal -= calculerRemiseSupplementaire(article);
    }
    return prixFinal;
}

private double calculerRemiseSupplementaire(Article article) {
    return article.getQuantite() > 5 ? article.getPrix() * 0.05 : 0; // Remise suppl√©mentaire pour les achats de plus de 5 articles
}
```

### Liste de param√®tres longues

Lorsque vous programmez, vous avez probablement appris √† passer tous les √©l√©ments n√©cessaires √† une fonction en tant que param√®tres. Cependant, avoir une longue liste de param√®tres peut rapidement devenir source de confusion.

Je vais vous pr√©senter deux cas pour illustrer ce point.

#### Cas 1 : Tous les param√®tres proviennent de la m√™me classe

Prenons l‚Äôexemple d‚Äôune classe `Voiture` qui a plusieurs attributs :

```python
class Voiture:
    def __init__(self, marque, modele, annee, couleur, kilometrage, prix):
        self.marque = marque
        self.modele = modele
        self.annee = annee
        self.couleur = couleur
        self.kilometrage = kilometrage
        self.prix = prix
        # D'autres attributs non n√©cessaires pour la m√©thode d'affichage
        self.type_carburant = None
        self.nombre_portes = None

class GestionnaireDeVoiture:
    @staticmethod
    def afficher_informations_voiture(marque, modele, annee, couleur, kilometrage, prix):
        print(f"Voiture: {marque} {modele}, {annee} - "
              f"Couleur: {couleur}, Kilom√©trage: {kilometrage} km, "
              f"Prix: {prix} ‚Ç¨.")
```

Ici, lorsque nous voulons afficher les informations de la voiture, nous devons passer tous ses attributs comme param√®tres :

```python
# Utilisation
ma_voiture = Voiture("Toyota", "Corolla", 2020, "Rouge", 15000, 20000)

# Appel de la m√©thode avec une longue liste de param√®tres
GestionnaireDeVoiture.afficher_informations_voiture(
    ma_voiture.marque,
    ma_voiture.modele,
    ma_voiture.annee,
    ma_voiture.couleur,
    ma_voiture.kilometrage,
    ma_voiture.prix
)
```

Dans ce cas, m√™me si tous les attributs ne sont pas n√©cessaires √† la m√©thode, il est pr√©f√©rable de passer l'objet complet. C'est ce qu'on appelle le principe de **Pr√©server l'Objet Complet** :

```python
class GestionnaireDeVoiture:
    @staticmethod
    def afficher_informations_voiture(voiture):
        print(f"Voiture: {voiture.marque} {voiture.modele}, {voiture.annee} - "
              f"Couleur: {voiture.couleur}, Kilom√©trage: {voiture.kilometrage} km, "
              f"Prix: {voiture.prix} ‚Ç¨.")
```

Maintenant, nous pouvons appeler la m√©thode de cette mani√®re :

```python
# Appel de la m√©thode statique avec l'objet complet
GestionnaireDeVoiture.afficher_informations_voiture(ma_voiture)
```

#### Cas 2 : Les param√®tres proviennent de classes diff√©rentes

Imaginons maintenant que nous ayons une classe `Personne` et une classe `Adresse` :

```python
class Personne:
    def __init__(self, nom, prenom, age):
        self.nom = nom
        self.prenom = prenom
        self.age = age
        # D'autres attributs
        self.sexe = None
        self.date_naissance = None

class Adresse:
    def __init__(self, rue, ville, code_postal):
        self.rue = rue
        self.ville = ville
        self.code_postal = code_postal
        # D'autres attributs
        self.pays = None
        self.region = None

def envoyer_invitation(nom, prenom, age, rue, ville, code_postal):
    print(f"Invitation envoy√©e √† {prenom} {nom}, {age} ans, √† l'adresse suivante : {rue}, "
          f"{ville}, {code_postal}.")
```

Dans cet exemple, nous devons passer plusieurs param√®tres provenant de deux classes diff√©rentes :

```python
# Utilisation
personne = Personne("Dupont", "Jean", 30)
adresse = Adresse("10 Rue des Fleurs", "Paris", "75000")

# Appel de la fonction avec une longue liste de param√®tres
envoyer_invitation(
    personne.nom,
    personne.prenom,
    personne.age,
    adresse.rue,
    adresse.ville,
    adresse.code_postal
)
```

Pour simplifier cela, nous pouvons combiner les informations de la personne et de l'adresse en un seul objet. C'est ce qu'on appelle le principe d‚Äô**Introduire un Objet Param√®tre**. Cela est encore plus utile si ces attributs sont souvent utilis√©s ensemble :

```python
class InformationsClient:
    def __init__(self, personne, adresse):
        self.nom = personne.nom
        self.prenom = personne.prenom
        self.age = personne.age
        self.rue = adresse.rue
        self.ville = adresse.ville
        self.code_postal = adresse.code_postal

class GestionnaireDeClient:
    @staticmethod
    def envoyer_invitation(informations_client):
        print(f"Invitation envoy√©e √† {informations_client.prenom} {informations_client.nom}, "
              f"{informations_client.age} ans, √† l'adresse suivante : {informations_client.rue}, "
              f"{informations_client.ville}, {informations_client.code_postal}.")
```

Voici comment nous utilisons ce nouveau syst√®me :

```python
# Utilisation
personne = Personne("Dupont", "Jean", 30)
adresse = Adresse("10 Rue des Fleurs", "Paris", "75000")
informations_client = InformationsClient(personne, adresse)

GestionnaireDeClient.envoyer_invitation(informations_client)
```



> Il existe de nombreux autres types de *code smells*, tels que les **Noms myst√©rieux**, qui d√©signent des noms de variables ou de fonctions peu clairs et ambigus, et la **Mutabilit√© des variables**, qui se r√©f√®re √† la modification d'une variable apr√®s sa cr√©ation, rendant le code moins pr√©visible. Bien que nous n'ayons pas le temps d'explorer ces concepts en cours, je vous encourage √† faire des recherches √† leur sujet, notamment dans le livre mentionn√© dans l'introduction.

## Normalisation des nommages : Introduction aux normes de nommage en Python

Des normes et des conventions de nommage existent pour am√©liorer la lisibilit√©, la maintenabilit√© et la compr√©hension du code. Chaque langage a ses propres normes et conventions, adapt√©es √† ses particularit√©s. 

Par exemple : 
- En **Python**, les variables sont g√©n√©ralement nomm√©es en `snake_case`.
- En **Java**, on pr√©f√®re le `camelCase` pour les noms de variables et de m√©thodes.

Les conventions de codage en Python sont d√©finies dans la [PEP 8](https://peps.python.org/pep-0008/), tandis que celles de Java sont d√©crites dans le document officiel [Code Conventions for the Java Programming Language](https://www.oracle.com/java/technologies/javase/codeconventions-contents.html).

Nous vous encourageons vivement √† consulter ces ressources pour d√©couvrir davantage d‚Äôexemples pr√©cis et des explications d√©taill√©es sur ces conventions. Leur respect permet de garantir un code clair, coh√©rent et facilement compr√©hensible, notamment dans un contexte de collaboration.


#### 1. Nommage des fichiers et des modules

- **Convention** : Utilisez des lettres minuscules et des underscores pour s√©parer les mots. 
- **Exemple** : `mon_script.py`, `utils.py`

#### 2. Nommage des classes

- **Convention** : Adoptez le style PascalCase pour les noms de classes, o√π chaque mot commence par une majuscule.
- **Exemple** : `MaClasse`, `GestionnaireDeFichiers`

#### 3. Nommage des variables et des arguments de fonction

- **Convention** : Utilisez des lettres minuscules avec des underscores pour s√©parer les mots.
- **Exemple** : `ma_variable`, `nombre_utilisateurs`
- **Remarque** : √âvitez les noms de variables ambigus ou trop g√©n√©riques.

#### 4. Nommage des fonctions et des m√©thodes

- **Convention** : Utilisez des lettres minuscules avec des underscores pour les noms de fonctions, comme pour les variables.
- **Exemple** : `calculer_somme`, `obtenir_utilisateur`
- **Remarque** : Les noms de fonctions doivent √™tre descriptifs et indiquer clairement leur objectif.

#### 5. Nommage des constantes

- **Convention** : Utilisez des lettres majuscules avec des underscores pour s√©parer les mots. Les constantes doivent √™tre d√©finies en haut du fichier ou du module.
- **Exemple** : `MAX_TAILLE`, `NOMBRE_MAXI_UTILISATEURS`

#### 6. Nommage des packages et des dossiers
- **Convention** : Utilisez des lettres minuscules et √©vitez les underscores. 
- **Exemple** : `monpackage`, `utilitaires`

#### 7. Autres bonnes pratiques

- **Utilisez des mots significatifs** : Choisissez des noms qui d√©crivent clairement le r√¥le d'une variable, d'une fonction ou d'une classe.
- **√âvitez les abr√©viations obscures** : Les noms doivent √™tre compr√©hensibles pour toute personne lisant le code.

Les fonctions et m√©thodes doivent √™tre nomm√©es en commen√ßant par un verbe √† l'infinitif, tandis que tous les autres √©l√©ments commencent par un nom.

> Il est pr√©f√©rable d'utiliser des noms longs et explicites plut√¥t que des noms courts dont la signification n'est claire qu'au moment du d√©veloppement. N'oubliez pas que dans un vrai projet, vous collaborez avec d'autres personnes, mais aussi avec vous-m√™me dans le futur, qui pourrait avoir oubli√© le contexte de ce bout de code.


## Patrons de conception 

Cette partie est largement bas√©e sur les 23 design patterns pr√©sent√©s dans le livre : 

> Design Patterns: Elements of Reusable Object-Oriented Software (Addison-Wesley Professional Computing Series), Gamma Erich, Richard Helm, Ralph Johnson, John Vissidies, 1994


Les patrons de conception ou design patterns sont des arrangements caract√©ristiques logiques permettant la bonne conception de modules applicatifs logiciels en Programmation Orient√©e Objet. Il en existe une multitude r√©pondant a des probl√©matiques de r√©utilisabilit√© et d'impl√©mentation qualitative.

> En g√©n√©ral, on pr√©sente un patron en r√©ponse a une probl√©matique

### Gang of Four (GoF), ou le conseil des 23 (et non 4) 

On distingue classiquement 3 cat√©gories des 23 design patterns classiques : 
- Les Cr√©ationnels (structurent la mani√®re de cr√©er des objets).
- Les Structuraux (organisent les relations entre les classes et les objets).
- Les Comportementaux (d√©finissent comment les objets interagissent entre eux).

> Remarque : L'on retrouve une liste exhaustive des 23 ici : https://refactoring.guru/fr/design-patterns/catalog

Dans les faits, leur mise en place est sp√©cifique a diff√©rentes situations, il est important de garder a l'esprit leur existence pour l'application dans des cas appropri√©s.

### Quelques exemples

Dans cette partie on retrouve diff√©rents patterns que l'on pr√©sente dans le cadre de ce cours et que l'on souhaiterait voir appliqu√©s a diff√©rents √©l√©ments de vos logiciels.


#### 1. `Singleton` : 

Dans votre projet , l'utilitaire de connexion a la base de donn√©es √©tait unique.

> Le design pattern singleton isole le constructeur d'une classe et en fournit une impl√©mentation unique par le biais d'un remplacement de ce constructeur a un get d'une instance **statique**. Cela permet d'avoir une seule et unique configuration dans tout le code.

Cas d'application :
- **Logger**
- **Connecteur SGBD**
- **Gestionnaire d'authentification**
...

Pour l'exemple : vous voulez un logger dans votre application, logguer les erreurs graves dans un fichier et les autres dans la console :

```python
import logging
from typing import Optional, Literal

class Singleton(type):
    """ A metaclass that creates a Singleton base class when called. """
    _instances = {}
    
    def __call__(cls, *args, **kwargs):
        if cls not in cls._instances:
            cls._instances[cls] = super(Singleton, cls).__call__(*args, **kwargs)
        return cls._instances[cls]

class Logger(metaclass=Singleton):
    _logger = None  # Variable pour stocker le logger singleton

    def setup(self, log_level: Literal['DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL'],
              log_file: Optional[str] = None):
        """
        Configure le logger au d√©marrage avec le niveau de log et le fichier de log. 
        Pour info le niveau de log, c'est le niveau minimal de log que le logger accepte d'output
        """
        if Logger._logger is not None:
            raise RuntimeError("Logger d√©j√† configur√©!")

        Logger._logger = logging.getLogger(__name__)
        Logger._logger.setLevel(log_level)

        # Cr√©er un formatteur
        formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')

        # Si un fichier est sp√©cifi√©, alors on utilise un FileHandler
        if log_file:
            file_handler = logging.FileHandler(log_file, encoding='utf-8')
            file_handler.setFormatter(formatter)
            Logger._logger.addHandler(file_handler)
    @staticmethod
    def get_logger():
        if Logger._logger is None:
            raise RuntimeError("Logger non configur√©, appelez setup() d'abord.")
        return Logger._logger

    def log_info(self, message: str):
        Logger._logger.info(message)

    def log_debug(self, message: str):
        Logger._logger.debug(message)

    def log_warning(self, message: str):
        Logger._logger.warning(message)

    def log_error(self, message: str):
        Logger._logger.error(message)

    def log_critical(self, message: str):
        Logger._logger.critical(message)

# Exemple d'utilisation
if __name__ == "__main__":
    # Configuration du logger au d√©marrage avec un fichier de log et niveau INFO
    logger_initializer = Logger()
    logger_initializer.setup(log_level='INFO', log_file='output.log')
    # Obtenir l'instance initialis√©e ailleurs
    logger1: logging.Logger = Logger.get_logger()
    logger1.info("L'application pr√©cise l'invocation d'une fonction normale mais utile pour la compr√©hension de son execution <=> print")
    logger1.debug("L'application fait des op√©rations bas niveau qu'on ne doit regarder qu'en cas de d√©buggage")

    # Dans une autre classe on peut importer le logger avec le get_logger statique 
    logger2: logging.Logger = Logger.get_logger()
    logger2.warning("L'application pr√©cise un comportement anormal ou un probl√®me non bloquant")
    logger2.error("L'application pr√©cise un comportement critique qui pr√©cise un dysfonctionnement bloquant")
    # output.log
    ## XXXXXXXXXXXXXXX - INFO - L'application pr√©cise l'invocation d'une fonction normale mais utile pour la compr√©hension de son execution <=> print
    ## XXXXXXXXXXXXXXX - WARNING - L'application pr√©cise un comportement anormal ou un probl√®me non bloquant
    ## XXXXXXXXXXXXXXX - ERROR - L'application pr√©cise un comportement critique qui pr√©cise un dysfonctionnement bloquant

```

#### 2. Builder

L'id√©e du pattern builder est de permettre de construire des classes qui contiennent beaucoup d'attributs de mani√®re customis√©e. Cela permet donc d'alimenter la construction petit a petit et d'aboutir toutefois a un objet coh√©rent, puisque le builder s'appuie sur le r√©el constructeur de la classe.

Cela permet au global une cr√©ation plus lisible et plus flexible.

**exemple avec une classe de constitution d'un sandwich**
```python
class Sandwich:
    def __init__(self):
        self.bread:str | None = None
        self.protein:str | None = None
        self.cheese:str | None = None
        self.vegetables:list[str] = []
        self.sauces:list[str] = []
    @property
    def bread(self):
        return self._bread

    @bread.setter
    def bread(self, type_bread:str):
        self._bread = type_bread

    @property
    def protein(self):
        return self._protein

    @protein.setter
    def protein(self, type_protein: str):
        self._protein = type_protein

    @property
    def cheese(self):
        return self._cheese

    @cheese.setter
    def cheese(self, cheese_type:str):
        self._cheese = cheese_type

    @property
    def vegetables(self):
        return self._vegetables
    @vegetables.setter
    def vegetables(self, vegetables:list[str]):
        self._vegetables = vegetables
    def add_vegetable(self, vegetable:str):
        if vegetable:
            self._vegetables.append(vegetable)

    @property
    def sauces(self):
        return self._sauces
    @sauces.setter
    def sauces(self, sauces:list[str]):
        self._sauces = sauces
    def add_sauce(self, sauce:str):
        if sauce:
            self._sauces.append(sauce)

    def __str__(self):
        return (
            f"Sandwich(bread={self.bread}, protein={self.protein}, "
            f"cheese={self.cheese}, vegetables={self.vegetables}, sauces={self.sauces})"
        )

class SandwichBuilder:
    def __init__(self):
        self.sandwich = Sandwich()

    def set_bread(self, bread:str):
        self.sandwich.bread = bread
        return self

    def set_protein(self, protein:str):
        self.sandwich.protein = protein
        return self

    def add_cheese(self, cheese:str):
        self.sandwich.cheese = cheese
        return self

    def add_vegetable(self, vegetable:list[str]):
        self.sandwich.vegetables.append(vegetable)
        return self

    def add_sauce(self, sauce:list[str]):
        self.sandwich.sauces.append(sauce)
        return self

    def build(self):
        return self.sandwich

# Exemple d'utilisation
if __name__ == "__main__":
    builder = SandwichBuilder()
    custom_sandwich = (
        builder.set_bread("Italian")
               .set_protein("Chicken Teriyaki")
               .add_cheese("Swiss")
               .add_vegetable("Lettuce")
               .add_vegetable("Tomato")
               .add_vegetable("Pickles")
               .add_sauce("Honey Mustard")
               .add_sauce("Chipotle Southwest")
               .build()
    )
    print(custom_sandwich)
    # Sandwich(bread=Italian, protein=Chicken Teriyaki, cheese=Swiss, vegetables=['Lettuce','Tomato','Pickles'], sauces=['Honey Mustard', 'Chipotle Southwest'])
```
#### 3. Factory

Le principe du pattern Factory et de construire un objet a partir d'une classe p√®re sans donner la classe, cela permet de d√©coupler les constructeurs des cr√©ations d'objets, puisqu'on peut √™tre amen√©s a faire √©voluer les constructeurs de mani√®re ind√©pendante pour plusieurs classes filles par exemple.

Exemple avec des impl√©mentations de nuages : 

```python
from abc import abstractmethod
from typing import Literal


class Cloud:
    """Classe de base pour tous les types de nuages."""
    def __init__(self, size: str, altitude: str):
        self.size = size  # Taille du nuage (petit, moyen, grand)
        self.altitude = altitude  # Altitude du nuage (basse, moyenne, haute)
        self.color = self._default_color()  # Couleur par d√©faut selon le type de nuage
    @abstractmethod
    def _default_color(self) -> Literal["gris", "noir", "blanc"]:
        raise NotImplementedError("Chaque type de nuage doit d√©finir sa couleur par d√©faut.")

    def _default_event(self) -> str:
        return  "reste calme et n'a aucun effet m√©t√©orologique."
    def generate_weather(self) -> str:
        return f"Le nuage {self.size}, de couleur {self._default_color()}, situ√© √† {self.altitude} altitude, {self._default_event()}."

    def __str__(self):
        return f"Cloud(size={self.size}, altitude={self.altitude}, color={self.color})"

class RainCloud(Cloud):
    """Nuage produisant de la pluie."""
    def _default_color(self) -> Literal["gris"]:
        return "gris"
    def _default_event(self) -> str:
        return "produit de la pluie"

class ThunderCloud(Cloud):
    """Nuage produisant des orages."""
    def _default_color(self) -> Literal["noir"]:
        return "noir"
    def _default_event(self) -> str:
        return " produit des √©clairs et du tonnerre !"

class NeutralCloud(Cloud):
    """Nuage sans effet m√©t√©orologique."""
    def _default_color(self) -> Literal["blanc"]:
        return "blanc"

class CloudFactory:
    """Factory pour cr√©er des nuages en fonction du type et des param√®tres."""
    @staticmethod
    def create_cloud(cloud_type: Literal["rain", "thunder", "neutral"], size: str, altitude: str) -> Cloud:
        if cloud_type == "rain":
            return RainCloud(size, altitude)
        elif cloud_type == "thunder":
            return ThunderCloud(size, altitude)
        elif cloud_type == "neutral":
            return NeutralCloud(size, altitude)
        else:
            raise ValueError(f"Type de nuage inconnu : {cloud_type}")

# Exemple d'utilisation
if __name__ == "__main__":
    # Cr√©er un nuage de pluie
    rain_cloud = CloudFactory.create_cloud("rain", size="grand", altitude="moyenne")
    print(rain_cloud)
    print(rain_cloud.generate_weather())  
    # Le nuage grand, de couleur gris, situ√© √† moyenne altitude, produit de la pluie.

    # Cr√©er un nuage d'orage
    thunder_cloud = CloudFactory.create_cloud("thunder", size="immense", altitude="haute")
    print(thunder_cloud)
    print(thunder_cloud.generate_weather()) 
    # Le nuage immense, de couleur noir, situ√© √† haute altitude,  produit des √©clairs et du tonnerre !.

    # Cr√©er un nuage neutre
    neutral_cloud = CloudFactory.create_cloud("neutral", size="petit", altitude="basse")
    print(neutral_cloud)
    print(neutral_cloud.generate_weather())  
    # Le nuage petit, de couleur blanc, situ√© √† basse altitude, reste calme et n'a aucun effet m√©t√©orologique..


```
#### 4. `Data Transfer Object` : 

Le pattern DTO (Data Transfer Object) est utilis√© pour transporter des donn√©es entre diff√©rentes couches d'une application.

> Il a √©t√© d√©fini dans le livre : `Patterns of Enterprise Application Architecture` https://martinfowler.com/books/eaa.html (donc a posteriori)

Il permet :

- De s√©parer les donn√©es de transfert des entit√©s m√©tier pour √©viter de les exposer directement.
- De centraliser la validation des donn√©es avant qu'elles ne soient utilis√©es par les couches m√©tier.
- D'am√©liorer la s√©curit√© et la maintenabilit√© en contr√¥lant pr√©cis√©ment ce qui est transf√©r√© et expos√©.

Un DTO est g√©n√©ralement utilis√© dans le contexte d'une API ou d'un syst√®me distribu√© pour s√©rialiser et d√©s√©rialiser les donn√©es entrantes/sortantes.

Exemple dans le cadre d'une api FastAPI pour la validation d'un User avant de l'entr√©e dans le syst√®me :

```python
from fastapi import HTTPException, FastAPI
from typing import List

from pydantic import BaseModel, Field

app = FastAPI()

import sqlite3
from typing import Optional, Literal

class Singleton(type):
    """ A metaclass that creates a Singleton base class when called. """
    _instances = {}

    def __call__(cls, *args, **kwargs):
        if cls not in cls._instances:
            cls._instances[cls] = super(Singleton, cls).__call__(*args, **kwargs)
        return cls._instances[cls]

class DatabaseConnector(metaclass=Singleton):
    _connection = None

    def __init__(self, db_type: Literal['sqlite'] = 'sqlite', 
                 db_name: Optional[str] = 'default.db'):
        self.db_type = db_type
        self.db_name = db_name
        self.connect()       
    def _connect_sqlite(self, db_name):
        try:
            DatabaseConnector._connection = sqlite3.connect(db_name)
        except sqlite3.Error as e:
            print(f"Erreur de connexion SQLite : {e}")

    def connect(self):
        if DatabaseConnector._connection is not None:
            raise RuntimeError("Base de donn√©es d√©j√† connect√©e!")
        
        if self.db_type == 'sqlite':
            self._connect_sqlite(self.db_name)
        else:
            raise ValueError("Type de base de donn√©es inconnu. Choisissez 'sqlite' ou '?'.")
 
    def init_db(self):
        if self.db_type == 'sqlite':
            connexion = self.get_connection()
            cursor = connexion.cursor()
            # creation table users
            cursor.execute('''DROP TABLE IF EXISTS users;''')
            cursor.execute('''CREATE TABLE IF NOT EXISTS users (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        username TEXT NOT NULL
                    );''')
            cursor.execute('''DROP TABLE IF EXISTS roles_users;''')
            cursor.execute('''CREATE TABLE IF NOT EXISTS roles_user (
                        user_id INTEGER NOT NULL,
                        role TEXT NOT NULL,
                        FOREIGN KEY (user_id) REFERENCES users (id)
                    );''')
            connexion.commit()
            # Insertion d'un utilisateur 'admin'
            cursor.execute("INSERT INTO users (username) VALUES (?)", ("adm",))
            user_id = cursor.lastrowid  # R√©cup√®re l'id du nouvel utilisateur
            # Insertion du r√¥le 'admin' pour cet utilisateur
            cursor.execute("INSERT INTO roles_user (user_id, role) VALUES (?, ?)", (user_id, "admin"))
            cursor.execute("INSERT INTO roles_user (user_id, role) VALUES (?, ?)", (user_id, "dev"))
            connexion.commit()
            user_id = cursor.lastrowid 
            cursor.execute("INSERT INTO users (username) VALUES (?)", ("pasadm",))
            cursor.execute("INSERT INTO roles_user (user_id, role) VALUES (?, ?)", (user_id, "dev"))
             # Commit des changements
            connexion.commit()
            self.close_connection()

    def get_connection(self):
        if DatabaseConnector._connection is None:
            self.connect()
        return DatabaseConnector._connection
    def close_connection(self):
        """ Ferme la connexion √† la base de donn√©es si elle est ouverte. """
        if DatabaseConnector._connection is not None:
            DatabaseConnector._connection.close()
            DatabaseConnector._connection = None

# --- Entit√© m√©tier ---
class UserDTO(BaseModel):
    username: str = Field(examples=["adm","pasadm"])
    def to_user(self):
        """Convert DTO to a plain User object."""
        return User(
            id=None,
            username=self.username,
            roles=None
        )
class User:
    def __init__(self, id: Optional[str], username: str, roles: Optional[List[str]]):
        self.id = id
        self.username = username
        self.roles = roles
    def __str__(self):
        return f"User(username={self.username},roles={self.roles})"
    def __repr__(self):
        return f"User(username={self.username}, roles={self.roles})"
    def is_admin(self):
        return "admin" in self.roles

class UserDAO:
    def __init__(self, database_connector:DatabaseConnector):
        self.database_connector = database_connector
    def get_user_by_username(self, username:str ) :
        connexion = self.database_connector.get_connection()
        cursor = connexion.cursor() 
        cursor.execute("SELECT * FROM users a WHERE username = ?", (username,))
        user_dict = cursor.fetchone()
        if user_dict is None:
            raise ValueError(f"Pas d'utilisateur avec username {username}")
        cursor.execute("SELECT role from roles_user where user_id = ?",(str(user_dict[0])))
        roles = cursor.fetchall()
        distinct_roles = list(set(role[0] for role in roles))
        user = User(id=user_dict[0], username=user_dict[1],roles=distinct_roles)
        self.database_connector.close_connection()
        return user
    def save_user(self, name: str, email: str) -> int:
        cursor = self._conn.cursor()
        cursor.execute("INSERT INTO users (name, email) VALUES (?, ?)", (name, email))
        self._conn.commit()
        return cursor.lastrowid
#
# --- M√©thode d√©cor√©e ---
class UserService:
    def __init__(self, user_dao:UserDAO):
        self.user_dao = user_dao
    def peut_se_connecter(self,user: User):
        """V√©rifie si l'utilisateur peut se connecter (uniquement pour les administrateurs)."""
        print(user)
        if user.is_admin():
            return {"message": f"User {user.username} can connect as admin."}
        return {"message": f"User {user.username} cannotconnect as admin."}
    def get_user(self,user_dto:UserDTO):
        user = user_dto.to_user()
        updated_user = self.user_dao.get_user_by_username(user.username)
        return updated_user 
# --- API Endpoint ---
@app.post("/connect")
def connect(user_dto: UserDTO):
    """
    Endpoint qui utilise la m√©thode `peut_se_connecter` pour v√©rifier si l'utilisateur peut acc√©der.
    Un utilisateur avec le r√¥le "admin" est n√©cessaire.
    """
    user_dao = UserDAO(database_connector=DatabaseConnector())
    user_service = UserService(user_dao=user_dao)
    try:
        user = user_service.get_user(user_dto=user_dto)
        return user_service.peut_se_connecter(user=user)
    except ValueError as e:
        raise HTTPException(404,str(e))

if __name__ == "__main__":
    import uvicorn
    # initialisation du connector
    database_connector = DatabaseConnector("sqlite","default.db")
    # initialisation de la bdd : schema et donnees
    database_connector.init_db()
    # Run server
    uvicorn.run(app, host="0.0.0.0", port=8000)``

L'avantage est l'isolation des donn√©es d'entr√©e et de sortie du syst√®me et de ne pas demander la saisie int√©grale du champ user alors que l'on a seulement besoin d'un identifiant ou identifiant et mail par exemple.

> Ô∏è‚Äçüî•Ô∏è‚Äçüî•Ô∏è‚Äçüî• Si l'on doit faire √©voluer, on peut faire √©voluer seulement l'entr√©e, ou seulement l'objet a l'int√©rieur du syst√®me. üî•Ô∏è‚Äçüî•Ô∏è‚Äçüî•


Remarque il en existe √©videmment beaucoup d'autres, et chacune de ces impl√©mentations √† ces limites donc il faut veiller a les utiliser lorsque c'est pertinent.
