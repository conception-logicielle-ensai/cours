---
title: ğŸ”° Bonnes pratiques du dÃ©veloppement et design patterns
url: "/docs/bonnes-pratiques-dev"
---

Cette partie est largement basÃ©e des concepts et exemples prÃ©sentÃ©s dans le livre :

> **Refactoring**, Improving the design of existing code. Martin Fowler, Kent Beck 1999.

Ce livre prÃ©sente un ensemble de problÃ¨mes que l'on peut retrouver dans une base de code et propose une rÃ©solution de ces problÃ¨mes par le respect de pratiques et de normes de dÃ©veloppement.

## Code smells

Les code smells sont des indices dans le code qui suggÃ¨rent des problÃ¨mes potentiels, rendant le code difficile Ã  comprendre, Ã  maintenir ou Ã  faire Ã©voluer. Ils ne sont pas nÃ©cessairement des bugs, mais indiquent souvent des faiblesses dans la conception, comme des fonctions trop longues, des dÃ©pendances complexes ou des rÃ©pÃ©titions inutiles.

L'identification des code smells aide Ã  repÃ©rer les zones du code qui pourraient bÃ©nÃ©ficier d'un refactoring.

> Pour aller plus loin : On retrouve diffÃ©rents des principaux code smells ici : https://refactoring.guru/refactoring/smells

### Magic Numbers

Le terme "magic number" dÃ©signe l'utilisation de constantes numÃ©riques non nommÃ©es dans le code source d'un programme. Cette pratique peut rendre le code difficile Ã  comprendre et Ã  maintenir, car elle obscurcit le sens des valeurs utilisÃ©es. En nommant explicitement toutes les constantes, on amÃ©liore la lisibilitÃ©, la comprÃ©hension et la maintenabilitÃ© du code, ce qui facilite la collaboration entre dÃ©veloppeurs.

#### Exemple de Code avec Magic Numbers

Voici un exemple illustrant l'utilisation de magic numbers dans le calcul de valeurs extrÃªmes et de moyennes glissantes :

```python
import numpy as np

def extreme(data):
    # Calcul de la moyenne et de l'Ã©cart-type
    mean = np.mean(data)
    std_dev = np.std(data)
    resultat = []  # Liste pour stocker les valeurs extrÃªmes
    for x in data:
        if abs(x - mean) > 3 * std_dev: 
            resultat.append(x)  # Utilisation de append pour ajouter des Ã©lÃ©ments
    return resultat  # Retourne la liste des valeurs extrÃªmes

# Calcul de la moyenne glissante sur une fenÃªtre de taille 3
def moyenne_glissante(data):
    """
    Calcule une moyenne glissante sur une fenÃªtre de taille 3.
    Les bords oÃ¹ il n'y a pas assez de valeurs retournent None.
    """
    if len(data) < 3:
        return [None] * len(data)

    resultats = [None]  # Padding initial pour le bord gauche
    for i in range(1, len(data) - 1):
        moyenne = np.mean(data[i - 1:i + 2])  # Calcul de la moyenne glissante
        resultats.append(moyenne)
    resultats.append(None)  # Padding final pour le bord droit
    return resultats

# DonnÃ©es
data = [100, 102, 98, 97, 250, 101, 99, 102]
# Identification des valeurs extrÃªmes (plus de 3 Ã©carts-types de la moyenne)
extremes = extreme(data)
print(f"Valeurs extrÃªmes : {extremes}")
# Calcul et affichage de la moyenne glissante
glissement = moyenne_glissante(data)
print(f"Moyenne glissante sur 3 : {glissement}")
```

<details><summary><b>Pourquoi Ã©viter les Magic Numbers ? (Cliquez ici pour en savoir plus)</b></summary>
<p>

<h3>Pourquoi Ã‰viter les Magic Numbers ?</h3>

L'utilisation de **magic numbers** dans le code prÃ©sente plusieurs inconvÃ©nients majeurs :

- **Manque de clartÃ©** : Lorsqu'un dÃ©veloppeur lit le code, il peut se demander : Â« Pourquoi cette valeur ? Â». Par exemple, une condition impliquant la valeur `3` pour un Ã©cart-type peut sembler arbitraire. Cela complique la comprÃ©hension rapide du code et nÃ©cessite une rÃ©flexion supplÃ©mentaire pour deviner la signification de la valeur.

- **AmbiguÃ¯tÃ©** : Les magic numbers peuvent prÃªter Ã  confusion lorsqu'ils sont utilisÃ©s pour reprÃ©senter des concepts diffÃ©rents dans le mÃªme programme. Par exemple, si deux variables distinctes partagent la mÃªme valeur, cela complique l'identification de leur rÃ´le respectif.

- **DifficultÃ© de maintenance** : Modifier une valeur magique peut entraÃ®ner des erreurs, car cette valeur est souvent utilisÃ©e Ã  plusieurs endroits. Par exemple, pour passer d'une taille de moyenne glissante de `3` Ã  `5`, un dÃ©veloppeur pourrait remplacer toutes les occurrences de `3` par `5`. Cela risque d'introduire des bugs, notamment si certaines parties du code, comme une expression du type `[i - 1:i + 2]`, ne sont pas correctement adaptÃ©es.

</p>
</details>


#### AmÃ©lioration du Code

Pour Ã©viter l'utilisation de magic numbers, il est prÃ©fÃ©rable de dÃ©finir des constantes nommÃ©es :

```python
import numpy as np

# DÃ©finition des constantes
TAILLE_FENETRE_GLISSANTE = 3
MULTIPLICATEUR_SEUIL = 3

def extreme(data):
    # Calcul de la moyenne et de l'Ã©cart-type
    mean = np.mean(data)
    std_dev = np.std(data)
    resultat = []  # Liste pour stocker les valeurs extrÃªmes
    for x in data:
        if abs(x - mean) > MULTIPLICATEUR_SEUIL * std_dev:  # Utilisation de la constante
            resultat.append(x)
    return resultat  # Retourne la liste des valeurs extrÃªmes

# Calcul de la moyenne glissante sur une fenÃªtre de taille dÃ©finie
def moyenne_glissante(data):
    """
    Calcule une moyenne glissante sur une fenÃªtre de taille dÃ©finie.
    Les bords oÃ¹ il n'y a pas assez de valeurs retournent None.
    """
    if len(data) < TAILLE_FENETRE_GLISSANTE:
        return [None] * len(data)

    resultats = [None]  # Padding initial pour le bord gauche
    for i in range(1, len(data) - 1):
        moyenne = np.mean(data[i - 1:i + TAILLE_FENETRE_GLISSANTE - 1])  # Utilisation de la constante
        resultats.append(moyenne)
    resultats.append(None)  # Padding final pour le bord droit
    return resultats

# DonnÃ©es
data = [100, 102, 98, 97, 250, 101, 99, 102]
# Identification des valeurs extrÃªmes (plus de 3 Ã©carts-types de la moyenne)
extremes = extreme(data)
print(f"Valeurs extrÃªmes : {extremes}")
# Calcul et affichage de la moyenne glissante
glissement = moyenne_glissante(data)
print(f"Moyenne glissante sur 3 : {glissement}")
```

Dans ce code amÃ©liorÃ©, la modification de la valeur de `TAILLE_FENETRE_GLISSANTE` ou `MULTIPLICATEUR_SEUIL` ne nÃ©cessite qu'une seule intervention, ce qui facilite la maintenance.

#### Comment Ã‰viter les Magic Numbers ?

Pour Ã©viter les magic numbers :

- **Utilisez des Constantes NommÃ©es** : DÃ©clarez les constantes en MAJUSCULES au dÃ©but de vos fichiers ou fonctions. Cela facilite leur recherche et modification. Par exemple, `MULTIPLICATEUR_SEUIL = 3` peut Ãªtre considÃ©rÃ© comme une vÃ©ritÃ© statistique, donc il est peu probable qu'elle change.

- **ParamÃ¨tres de Fonction** : Pour les valeurs qui peuvent nÃ©cessiter des ajustements, passez-les en paramÃ¨tres de fonction. Par exemple, dans `moyenne_glissante`, cela a plus de sens de les traiter comme un paramÃ¨tre, ce qui permet d'associer une valeur explicite Ã  la fenÃªtre glissante.


Les problÃ¨mes liÃ©s aux magic numbers ne se limitent pas aux constantes numÃ©riques. Ce terme s'applique Ã©galement Ã  d'autres types de donnÃ©es. Par exemple, dÃ©clarer const string testNomUtilisateur = "Jean" est prÃ©fÃ©rable Ã  l'utilisation directe du mot "Jean" Ã  plusieurs endroits dans le programme.

> En gros dÃ¨s que vous avez des string ou des nombre (entier ou flotant) Ã©crit en dur, c'est que vous avez mal fait les chose.

### Code DupliquÃ©

Le code dupliquÃ© est un problÃ¨me frÃ©quent qui peut rendre votre programme plus difficile Ã  maintenir. Chaque fois que vous dupliquez des structures similaires dans votre code, vous introduisez un risque d'incohÃ©rence. Si vous devez modifier une de ces copies, vous devez vous assurer que toutes les autres sont mises Ã  jour en consÃ©quence. Cela augmente la probabilitÃ© d'erreurs et complique la lecture et l'Ã©volution du code. La solution consiste Ã  unifier ces duplications en extrayant les parties communes.

---

#### **1. Si le code dupliquÃ© se trouve dans la mÃªme classe**

Code avec des lignes dupliquÃ©es :

```python
class Calculateur:
    def calculer_area_rectangle(self, largeur, hauteur):
        print("L'aire d'un rectangle est largeur * hauteur")
        return largeur * hauteur

    def calculer_area_carre(self, cote):
        print("L'aire d'un carrÃ© est cote * cote")
        return cote * cote
```

Dans cet exemple, la logique de multiplication est rÃ©pÃ©tÃ©e dans les deux mÃ©thodes. Pour Ã©viter cette duplication, nous pouvons extraire cette logique dans une mÃ©thode utilitaire.

Code mutualisÃ© :

```python
class Calculateur:
    def multiplier(self, a, b):
        return a * b  # MÃ©thode extraite pour Ã©viter la duplication

    def calculer_area_rectangle(self, largeur, hauteur):
        print("L'aire d'un rectangle est largeur * hauteur")
        return self.multiplier(largeur, hauteur)

    def calculer_area_carre(self, cote):
        print("L'aire d'un carrÃ© est cote * cote")
        return self.multiplier(cote, cote)
```

#### **2. Si le code dupliquÃ© se trouve dans des sous-classes**

Code avec des lignes dupliquÃ©es :

```python
class Forme:
    def area(self):
        pass  # MÃ©thode Ã  implÃ©menter dans les sous-classes

class Rectangle(Forme):
    def __init__(self, largeur, hauteur):
        self.largeur = largeur
        self.hauteur = hauteur

    def area(self):
        print("L'aire d'un rectangle est largeur * hauteur")
        return self.largeur * self.hauteur

class Carre(Forme):
    def __init__(self, cote):
        self.cote = cote

    def area(self):
        print("L'aire d'un carrÃ© est cote * cote")
        return self.cote * self.cote
```

Ici, la logique de multiplication est dupliquÃ©e dans les mÃ©thodes `area` de `Rectangle` et `Carre`. Pour Ã©viter cette duplication, nous pouvons utiliser la **mÃ©thode Pull Up**, qui consiste Ã  dÃ©placer le code commun dans la classe de base.

Code mutualisÃ© avec la mÃ©thode Pull Up :

```python
class Forme:
    def multiplier(self, a, b):
        return a * b  # MÃ©thode partagÃ©e pour Ã©viter la duplication

    def area(self):
        pass  # MÃ©thode gÃ©nÃ©rique Ã  spÃ©cialiser dans les sous-classes

class Rectangle(Forme):
    def __init__(self, largeur, hauteur):
        self.largeur = largeur
        self.hauteur = hauteur

    def area(self):
        print("L'aire d'un rectangle est largeur * hauteur")
        return self.multiplier(self.largeur, self.hauteur)

class Carre(Forme):
    def __init__(self, cote):
        self.cote = cote

    def area(self):
        print("L'aire d'un carrÃ© est cote * cote")
        return self.multiplier(self.cote, self.cote)
```

---

Le refactoring est un processus itÃ©ratif : commencez par des petits changements, testez rÃ©guliÃ¨rement et continuez Ã  amÃ©liorer le code progressivement.

### Fonctions trop longues

Dans la programmation, il est souvent observÃ© qu'une fonction trop longue devient difficile Ã  comprendre. Dans le passÃ©, les anciens langages de programmation avaient un inconvÃ©nient : appeler une sous-fonction Ã©tait coÃ»teux en termes de performance, ce qui dissuadait les dÃ©veloppeurs dâ€™utiliser des petites fonctions. Cependant, avec les langages modernes, ce coÃ»t est presque inexistant lorsquâ€™on reste dans le mÃªme processus.

Aujourd'hui, la vÃ©ritable contrainte liÃ©e aux petites fonctions rÃ©side dans le fait qu'elles demandent parfois un effort supplÃ©mentaire Ã  ceux qui lisent le code, car il faut ouvrir chaque fonction pour comprendre son rÃ´le. Heureusement, les outils de dÃ©veloppement modernes nous simplifient la tÃ¢che : on peut naviguer facilement vers la dÃ©finition d'une fonction ou afficher son contenu d'un simple clic.

Le vÃ©ritable avantage des petites fonctions, c'est leur nom. Un nom clair et prÃ©cis permet souvent de comprendre rapidement ce que fait la fonction, sans mÃªme avoir besoin d'en lire le contenu.

Prenons un exemple de fonction qui calcule le total d'une commande :

```java
public double calculerTotalCommande(List<Article> articles) {
    double total = 0;
    for (Article article : articles) {
        if (article.isEnPromotion()) {
            total += article.getPrix() * 0.9; // Remise de 10%
            if (article.getQuantite() > 5) {
                total += article.getPrix() * 0.05; // Remise supplÃ©mentaire pour les gros achats
            }
        } else {
            total += article.getPrix();
        }
    }
    return total;
}
```

Ici, un bloc de code qui est accompagnÃ© dâ€™un commentaire peut Ãªtre remplacÃ© par une mÃ©thode dont le nom rÃ©sume cette explication. MÃªme une simple ligne de code peut justifier son extraction si elle nÃ©cessite un Ã©claircissement. Les conditions et les boucles nous donnent Ã©galement des pistes pour effectuer cette extraction. Par exemple, un gros switch peut Ãªtre divisÃ© en appels de fonctions individuelles, et si plusieurs switch utilisent les mÃªmes conditions, on peut appliquer le polymorphisme pour amÃ©liorer la lisibilitÃ©.

Pour les boucles, il est Ã©galement judicieux d'extraire la boucle et son contenu dans une mÃ©thode sÃ©parÃ©e. Si vous avez du mal Ã  nommer une boucle extraite, cela peut indiquer qu'elle rÃ©alise deux tÃ¢ches diffÃ©rentes. Dans ce cas, nâ€™hÃ©sitez pas Ã  diviser les boucles pour isoler les diffÃ©rentes tÃ¢ches.

Voici comment nous pourrions refactoriser la fonction pour la rendre plus lisible :

```java
public double calculerTotalCommande(List<Article> articles) {
    double total = 0;
    for (Article article : articles) {
        total += calculerPrixArticle(article);
    }
    return total;
}

private double calculerPrixArticle(Article article) {
    double prixFinal = article.getPrix();
    if (article.isEnPromotion()) {
        prixFinal *= 0.9; // Remise de 10%
        prixFinal -= calculerRemiseSupplementaire(article);
    }
    return prixFinal;
}

private double calculerRemiseSupplementaire(Article article) {
    return article.getQuantite() > 5 ? article.getPrix() * 0.05 : 0; // Remise supplÃ©mentaire pour les achats de plus de 5 articles
}
```

### Liste de paramÃ¨tres longues

Lorsque vous programmez, vous avez probablement appris Ã  passer tous les Ã©lÃ©ments nÃ©cessaires Ã  une fonction en tant que paramÃ¨tres. Cependant, avoir une longue liste de paramÃ¨tres peut rapidement devenir source de confusion.

Je vais vous prÃ©senter deux cas pour illustrer ce point.

#### Cas 1 : Tous les paramÃ¨tres proviennent de la mÃªme classe

Prenons lâ€™exemple dâ€™une classe `Voiture` qui a plusieurs attributs :

```python
class Voiture:
    def __init__(self, marque, modele, annee, couleur, kilometrage, prix):
        self.marque = marque
        self.modele = modele
        self.annee = annee
        self.couleur = couleur
        self.kilometrage = kilometrage
        self.prix = prix
        # D'autres attributs non nÃ©cessaires pour la mÃ©thode d'affichage
        self.type_carburant = None
        self.nombre_portes = None

class GestionnaireDeVoiture:
    @staticmethod
    def afficher_informations_voiture(marque, modele, annee, couleur, kilometrage, prix):
        print(f"Voiture: {marque} {modele}, {annee} - "
              f"Couleur: {couleur}, KilomÃ©trage: {kilometrage} km, "
              f"Prix: {prix} â‚¬.")
```

Ici, lorsque nous voulons afficher les informations de la voiture, nous devons passer tous ses attributs comme paramÃ¨tres :

```python
# Utilisation
ma_voiture = Voiture("Toyota", "Corolla", 2020, "Rouge", 15000, 20000)

# Appel de la mÃ©thode avec une longue liste de paramÃ¨tres
GestionnaireDeVoiture.afficher_informations_voiture(
    ma_voiture.marque,
    ma_voiture.modele,
    ma_voiture.annee,
    ma_voiture.couleur,
    ma_voiture.kilometrage,
    ma_voiture.prix
)
```

Dans ce cas, mÃªme si tous les attributs ne sont pas nÃ©cessaires Ã  la mÃ©thode, il est prÃ©fÃ©rable de passer l'objet complet. C'est ce qu'on appelle le principe de **PrÃ©server l'Objet Complet** :

```python
class GestionnaireDeVoiture:
    @staticmethod
    def afficher_informations_voiture(voiture):
        print(f"Voiture: {voiture.marque} {voiture.modele}, {voiture.annee} - "
              f"Couleur: {voiture.couleur}, KilomÃ©trage: {voiture.kilometrage} km, "
              f"Prix: {voiture.prix} â‚¬.")
```

Maintenant, nous pouvons appeler la mÃ©thode de cette maniÃ¨re :

```python
# Appel de la mÃ©thode statique avec l'objet complet
GestionnaireDeVoiture.afficher_informations_voiture(ma_voiture)
```

#### Cas 2 : Les paramÃ¨tres proviennent de classes diffÃ©rentes

Imaginons maintenant que nous ayons une classe `Personne` et une classe `Adresse` :

```python
class Personne:
    def __init__(self, nom, prenom, age):
        self.nom = nom
        self.prenom = prenom
        self.age = age
        # D'autres attributs
        self.sexe = None
        self.date_naissance = None

class Adresse:
    def __init__(self, rue, ville, code_postal):
        self.rue = rue
        self.ville = ville
        self.code_postal = code_postal
        # D'autres attributs
        self.pays = None
        self.region = None

def envoyer_invitation(nom, prenom, age, rue, ville, code_postal):
    print(f"Invitation envoyÃ©e Ã  {prenom} {nom}, {age} ans, Ã  l'adresse suivante : {rue}, "
          f"{ville}, {code_postal}.")
```

Dans cet exemple, nous devons passer plusieurs paramÃ¨tres provenant de deux classes diffÃ©rentes :

```python
# Utilisation
personne = Personne("Dupont", "Jean", 30)
adresse = Adresse("10 Rue des Fleurs", "Paris", "75000")

# Appel de la fonction avec une longue liste de paramÃ¨tres
envoyer_invitation(
    personne.nom,
    personne.prenom,
    personne.age,
    adresse.rue,
    adresse.ville,
    adresse.code_postal
)
```

Pour simplifier cela, nous pouvons combiner les informations de la personne et de l'adresse en un seul objet. C'est ce qu'on appelle le principe dâ€™**Introduire un Objet ParamÃ¨tre**. Cela est encore plus utile si ces attributs sont souvent utilisÃ©s ensemble :

```python
class InformationsClient:
    def __init__(self, personne, adresse):
        self.nom = personne.nom
        self.prenom = personne.prenom
        self.age = personne.age
        self.rue = adresse.rue
        self.ville = adresse.ville
        self.code_postal = adresse.code_postal

class GestionnaireDeClient:
    @staticmethod
    def envoyer_invitation(informations_client):
        print(f"Invitation envoyÃ©e Ã  {informations_client.prenom} {informations_client.nom}, "
              f"{informations_client.age} ans, Ã  l'adresse suivante : {informations_client.rue}, "
              f"{informations_client.ville}, {informations_client.code_postal}.")
```

Voici comment nous utilisons ce nouveau systÃ¨me :

```python
# Utilisation
personne = Personne("Dupont", "Jean", 30)
adresse = Adresse("10 Rue des Fleurs", "Paris", "75000")
informations_client = InformationsClient(personne, adresse)

GestionnaireDeClient.envoyer_invitation(informations_client)
```



> Il existe de nombreux autres types de *code smells*, tels que les **Noms mystÃ©rieux**, qui dÃ©signent des noms de variables ou de fonctions peu clairs et ambigus, et la **MutabilitÃ© des variables**, qui se rÃ©fÃ¨re Ã  la modification d'une variable aprÃ¨s sa crÃ©ation, rendant le code moins prÃ©visible. Bien que nous n'ayons pas le temps d'explorer ces concepts en cours, je vous encourage Ã  faire des recherches Ã  leur sujet, notamment dans le livre mentionnÃ© dans l'introduction.

## Normalisation des nommages : Introduction aux normes de nommage en Python

Des normes et des conventions de nommage existent pour amÃ©liorer la lisibilitÃ©, la maintenabilitÃ© et la comprÃ©hension du code. Chaque langage a ses propres normes et conventions, adaptÃ©es Ã  ses particularitÃ©s. 

Par exemple : 
- En **Python**, les variables sont gÃ©nÃ©ralement nommÃ©es en `snake_case`.
- En **Java**, on prÃ©fÃ¨re le `camelCase` pour les noms de variables et de mÃ©thodes.

Les conventions de codage en Python sont dÃ©finies dans la [PEP 8](https://peps.python.org/pep-0008/), tandis que celles de Java sont dÃ©crites dans le document officiel [Code Conventions for the Java Programming Language](https://www.oracle.com/java/technologies/javase/codeconventions-contents.html).

Nous vous encourageons vivement Ã  consulter ces ressources pour dÃ©couvrir davantage dâ€™exemples prÃ©cis et des explications dÃ©taillÃ©es sur ces conventions. Leur respect permet de garantir un code clair, cohÃ©rent et facilement comprÃ©hensible, notamment dans un contexte de collaboration.


#### 1. Nommage des fichiers et des modules

- **Convention** : Utilisez des lettres minuscules et des underscores pour sÃ©parer les mots. 
- **Exemple** : `mon_script.py`, `utils.py`

#### 2. Nommage des classes

- **Convention** : Adoptez le style PascalCase pour les noms de classes, oÃ¹ chaque mot commence par une majuscule.
- **Exemple** : `MaClasse`, `GestionnaireDeFichiers`

#### 3. Nommage des variables et des arguments de fonction

- **Convention** : Utilisez des lettres minuscules avec des underscores pour sÃ©parer les mots.
- **Exemple** : `ma_variable`, `nombre_utilisateurs`
- **Remarque** : Ã‰vitez les noms de variables ambigus ou trop gÃ©nÃ©riques.

#### 4. Nommage des fonctions et des mÃ©thodes

- **Convention** : Utilisez des lettres minuscules avec des underscores pour les noms de fonctions, comme pour les variables.
- **Exemple** : `calculer_somme`, `obtenir_utilisateur`
- **Remarque** : Les noms de fonctions doivent Ãªtre descriptifs et indiquer clairement leur objectif.

#### 5. Nommage des constantes

- **Convention** : Utilisez des lettres majuscules avec des underscores pour sÃ©parer les mots. Les constantes doivent Ãªtre dÃ©finies en haut du fichier ou du module.
- **Exemple** : `MAX_TAILLE`, `NOMBRE_MAXI_UTILISATEURS`

#### 6. Nommage des packages et des dossiers
- **Convention** : Utilisez des lettres minuscules et Ã©vitez les underscores. 
- **Exemple** : `monpackage`, `utilitaires`

#### 7. Autres bonnes pratiques

- **Utilisez des mots significatifs** : Choisissez des noms qui dÃ©crivent clairement le rÃ´le d'une variable, d'une fonction ou d'une classe.
- **Ã‰vitez les abrÃ©viations obscures** : Les noms doivent Ãªtre comprÃ©hensibles pour toute personne lisant le code.

Les fonctions et mÃ©thodes doivent Ãªtre nommÃ©es en commenÃ§ant par un verbe Ã  l'infinitif, tandis que tous les autres Ã©lÃ©ments commencent par un nom.

> Il est prÃ©fÃ©rable d'utiliser des noms longs et explicites plutÃ´t que des noms courts dont la signification n'est claire qu'au moment du dÃ©veloppement. N'oubliez pas que dans un vrai projet, vous collaborez avec d'autres personnes, mais aussi avec vous-mÃªme dans le futur, qui pourrait avoir oubliÃ© le contexte de ce bout de code.


## Patrons de conception 

Cette partie est largement basÃ©e sur les 23 design patterns prÃ©sentÃ©s dans le livre : 

> Design Patterns: Elements of Reusable Object-Oriented Software (Addison-Wesley Professional Computing Series), Gamma Erich, Richard Helm, Ralph Johnson, John Vissidies, 1994


Les patrons de conception ou design patterns sont des arrangements caractÃ©ristiques logiques permettant la bonne conception de modules applicatifs logiciels en Programmation OrientÃ©e Objet. Il en existe une multitude rÃ©pondant a des problÃ©matiques de rÃ©utilisabilitÃ© et d'implÃ©mentation qualitative.

> En gÃ©nÃ©ral, on prÃ©sente un patron en rÃ©ponse a une problÃ©matique

### Gang of Four (GoF), ou le conseil des 23 (et non 4) 

On distingue classiquement 3 catÃ©gories des 23 design patterns classiques : 
- Les CrÃ©ationnels (structurent la maniÃ¨re de crÃ©er des objets).
- Les Structuraux (organisent les relations entre les classes et les objets).
- Les Comportementaux (dÃ©finissent comment les objets interagissent entre eux).

> Remarque : L'on retrouve une liste exhaustive des 23 ici : https://refactoring.guru/fr/design-patterns/catalog

Dans les faits, leur mise en place est spÃ©cifique a diffÃ©rentes situations, il est important de garder a l'esprit leur existence pour l'application dans des cas appropriÃ©s.

### Quelques exemples

Dans cette partie on retrouve diffÃ©rents patterns que l'on prÃ©sente dans le cadre de ce cours et que l'on souhaiterait voir appliquÃ©s a diffÃ©rents Ã©lÃ©ments de vos logiciels.

#### 1. `Singleton` : 

Dans votre projet , l'utilitaire de connexion a la base de donnÃ©es Ã©tait unique.

> Le design pattern singleton isole le constructeur d'une classe et en fournit une implÃ©mentation unique par le biais d'un remplacement de ce constructeur a un get d'une instance **statique**. Cela permet d'avoir une seule et unique configuration dans tout le code.

Cas d'application :
- **Logger**
- **Connecteur SGBD**
- **Gestionnaire d'authentification**
...

#### 2. `Data Transfer Object` : 

Le pattern DTO (Data Transfer Object) est utilisÃ© pour transporter des donnÃ©es entre diffÃ©rentes couches d'une application.

> Il a Ã©tÃ© dÃ©fini dans le livre : `Patterns of Enterprise Application Architecture` https://martinfowler.com/books/eaa.html

Il permet :

- De sÃ©parer les donnÃ©es de transfert des entitÃ©s mÃ©tier pour Ã©viter de les exposer directement.
- De centraliser la validation des donnÃ©es avant qu'elles ne soient utilisÃ©es par les couches mÃ©tier.
- D'amÃ©liorer la sÃ©curitÃ© et la maintenabilitÃ© en contrÃ´lant prÃ©cisÃ©ment ce qui est transfÃ©rÃ© et exposÃ©.

Un DTO est gÃ©nÃ©ralement utilisÃ© dans le contexte d'une API ou d'un systÃ¨me distribuÃ© pour sÃ©rialiser et dÃ©sÃ©rialiser les donnÃ©es entrantes/sortantes.

Exemple dans le cadre d'une api FastAPI pour la validation d'un User avant de l'entrÃ©e dans le systÃ¨me :

```python
from fastapi import HTTPException, Depends, FastAPI
from typing import List

app = FastAPI()

# --- EntitÃ© mÃ©tier ---
class UserDTO(BaseModel):
    username: str
    email: str
    def to_user(self):
        """Convert DTO to a plain User object."""
        return User(
            username=self.username,
            email=self.email
        )
class User:
    def __init__(self, username: str, email: str, roles: List[str]):
        self.username = username
        self.email = email
        self.roles = roles

    def __repr__(self):
        return f"User(username={self.username}, email={self.email}, roles={self.roles})"

# --- DÃ©corateur pour vÃ©rifier les rÃ´les ---
def requires_role(required_role: str):
    """DÃ©corateur pour vÃ©rifier qu'un utilisateur a un rÃ´le spÃ©cifique."""
    def decorator(method):
        def wrapper(user: User, *args, **kwargs):
            if required_role not in user.roles:
                raise HTTPException(status_code=403, detail=f"Access denied. Requires role: {required_role}")
            return method(user, *args, **kwargs)
        return wrapper
    return decorator

class UserDAO:
    def __init__(self, database:Database):
        self.database = database
    def get_user(self,user:User):
        return self.db_session.query(User).filter(User.id == user.username).first()
# --- MÃ©thode dÃ©corÃ©e ---
class UserService:
    def __init__(self, user_dao:UserDAO):
        self.user_dao = user_dao
    @staticmethod
    @requires_role("admin")
    def peut_se_connecter(user: User):
        """VÃ©rifie si l'utilisateur peut se connecter (uniquement pour les administrateurs)."""
        return {"message": f"User {user.username} can connect as admin."}
    def fetch_roles(self,user:User):
        updated_user = self.user_dao.fetch_roles(user)
        return updated_user 
# --- API Endpoint ---
@app.post("/connect")
def connect(user_dto: UserDTO = Depends(lambda: UserDto(username="JohnDoe", email="johndoe@example.com"))):
    """
    Endpoint qui utilise la mÃ©thode `peut_se_connecter` pour vÃ©rifier si l'utilisateur peut accÃ©der.
    Un utilisateur avec le rÃ´le "admin" est nÃ©cessaire.
    """
    return UserService.peut_se_connecter(userDTO.to_user())
```

L'avantage est l'isolation des donnÃ©es d'entrÃ©e et de sortie du systÃ¨me et de ne pas demander la saisie intÃ©grale du champ user alors que l'on a seulement besoin d'un identifiant ou identifiant et mail par exemple.

> ï¸â€ğŸ”¥ï¸â€ğŸ”¥ï¸â€ğŸ”¥ Si l'on doit faire Ã©voluer, on peut faire Ã©voluer seulement l'entrÃ©e, ou seulement l'objet a l'intÃ©rieur du systÃ¨me. ï¸â€ğŸ”¥ï¸â€ğŸ”¥ï¸â€ğŸ”¥

