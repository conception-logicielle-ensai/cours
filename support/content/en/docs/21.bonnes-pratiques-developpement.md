---
title: 🔰 Bonnes pratiques du développement et design patterns
url: "/docs/bonnes-pratiques-dev"
---
## ⚠️ C'est en travaux, revenez plus tard !

Notre page est actuellement en cours d'écriture et nous mettons tout en œuvre pour vous offrir la meilleure expérience possible. Nous vous prions de bien vouloir patienter, elle sera remplie prochainement.

Voici une version révisée de votre texte avec la correction idéale intégrée et une conclusion améliorée :

---


## Magic Numbers

Le terme "magic number" désigne l'utilisation de constantes numériques non nommées dans le code source d'un programme. Cette pratique peut rendre le code difficile à comprendre et à maintenir, car elle obscurcit le sens des valeurs utilisées. En nommant explicitement toutes les constantes, on améliore la lisibilité, la compréhension et la maintenabilité du code, ce qui facilite la collaboration entre développeurs.

### Exemple de Code avec Magic Numbers

Voici un exemple illustrant l'utilisation de magic numbers dans le calcul de valeurs extrêmes et de moyennes glissantes :

```python
import numpy as np

def extreme(data):
    # Calcul de la moyenne et de l'écart-type
    mean = np.mean(data)
    std_dev = np.std(data)
    resultat = []  # Liste pour stocker les valeurs extrêmes
    for x in data:
        if abs(x - mean) > 3 * std_dev: 
            resultat.append(x)  # Utilisation de append pour ajouter des éléments
    return resultat  # Retourne la liste des valeurs extrêmes

# Calcul de la moyenne glissante sur une fenêtre de taille 3
def moyenne_glissante(data):
    """
    Calcule une moyenne glissante sur une fenêtre de taille 3.
    Les bords où il n'y a pas assez de valeurs retournent None.
    """
    if len(data) < 3:
        return [None] * len(data)

    resultats = [None]  # Padding initial pour le bord gauche
    for i in range(1, len(data) - 1):
        moyenne = np.mean(data[i - 1:i + 2])  # Calcul de la moyenne glissante
        resultats.append(moyenne)
    resultats.append(None)  # Padding final pour le bord droit
    return resultats

# Données
data = [100, 102, 98, 97, 250, 101, 99, 102]
# Identification des valeurs extrêmes (plus de 3 écarts-types de la moyenne)
extremes = extreme(data)
print(f"Valeurs extrêmes : {extremes}")
# Calcul et affichage de la moyenne glissante
glissement = moyenne_glissante(data)
print(f"Moyenne glissante sur 3 : {glissement}")
```

### Pourquoi Éviter les Magic Numbers ?

L'utilisation de magic numbers présente plusieurs inconvénients :

- **Manque de Clarté** : Lorsqu'un développeur lit le code, il peut se demander « Pourquoi 3 ? » pour la condition d'écart-type. Cela complique la compréhension rapide du code et nécessite des réflexions supplémentaires pour comprendre le choix de cette valeur.
  
- **Ambiguïté** : Les magic numbers peuvent être déroutants lorsqu'ils sont utilisés pour des significations différentes au sein du même morceau de code. Par exemple, deux variables différentes pourraient avoir la même valeur, créant ainsi une confusion sur leur utilisation.

- **Difficulté de Maintenance** : Modifier une valeur magique peut être source d'erreurs, car elle est souvent utilisée à plusieurs endroits. Par exemple, pour adapter la taille de la moyenne glissante de 3 à 5, un développeur pourrait remplacer toutes les occurrences de 3 par 5. Cela pourrait entraîner des erreurs, notamment si certaines portions du code, comme l'expression `[i - 1:i + 2]`, ne sont pas mises à jour.

### Amélioration du Code

Pour éviter l'utilisation de magic numbers, il est préférable de définir des constantes nommées :

```python
import numpy as np

# Définition des constantes
TAILLE_FENETRE_GLISSANTE = 3
MULTIPLICATEUR_SEUIL = 3

def extreme(data):
    # Calcul de la moyenne et de l'écart-type
    mean = np.mean(data)
    std_dev = np.std(data)
    resultat = []  # Liste pour stocker les valeurs extrêmes
    for x in data:
        if abs(x - mean) > MULTIPLICATEUR_SEUIL * std_dev:  # Utilisation de la constante
            resultat.append(x)
    return resultat  # Retourne la liste des valeurs extrêmes

# Calcul de la moyenne glissante sur une fenêtre de taille définie
def moyenne_glissante(data):
    """
    Calcule une moyenne glissante sur une fenêtre de taille définie.
    Les bords où il n'y a pas assez de valeurs retournent None.
    """
    if len(data) < TAILLE_FENETRE_GLISSANTE:
        return [None] * len(data)

    resultats = [None]  # Padding initial pour le bord gauche
    for i in range(1, len(data) - 1):
        moyenne = np.mean(data[i - 1:i + TAILLE_FENETRE_GLISSANTE - 1])  # Utilisation de la constante
        resultats.append(moyenne)
    resultats.append(None)  # Padding final pour le bord droit
    return resultats

# Données
data = [100, 102, 98, 97, 250, 101, 99, 102]
# Identification des valeurs extrêmes (plus de 3 écarts-types de la moyenne)
extremes = extreme(data)
print(f"Valeurs extrêmes : {extremes}")
# Calcul et affichage de la moyenne glissante
glissement = moyenne_glissante(data)
print(f"Moyenne glissante sur 3 : {glissement}")
```

Dans ce code amélioré, la modification de la valeur de `TAILLE_FENETRE_GLISSANTE` ou `MULTIPLICATEUR_SEUIL` ne nécessite qu'une seule intervention, ce qui facilite la maintenance.

### Comment Éviter les Magic Numbers ?

Pour éviter les magic numbers :

- **Utilisez des Constantes Nommées** : Déclarez les constantes en MAJUSCULES au début de vos fichiers ou fonctions. Cela facilite leur recherche et modification. Par exemple, `MULTIPLICATEUR_SEUIL = 3` peut être considéré comme une vérité statistique, donc il est peu probable qu'elle change.

- **Paramètres de Fonction** : Pour les valeurs qui peuvent nécessiter des ajustements, passez-les en paramètres de fonction. Par exemple, dans `moyenne_glissante`, cela a plus de sens de les traiter comme un paramètre, ce qui permet d'associer une valeur explicite à la fenêtre glissante.

### Conclusion
Les problèmes liés aux magic numbers ne se limitent pas aux constantes numériques. Ce terme s'applique également à d'autres types de données. Par exemple, déclarer const string testNomUtilisateur = "Jean" est préférable à l'utilisation directe du mot "Jean" à plusieurs endroits dans le programme.

En gros dès que vous avez des string ou des nombre (entier ou flotant) écrit en dur, c'est que vous avez mal fait les chose.
Adopter des pratiques pour éviter les magic numbers permet non seulement d'améliorer la clarté et la lisibilité du code, mais aussi d'assurer une maintenance plus simple et moins sujette aux erreurs. En utilisant des constantes nommées et des paramètres de fonction, les développeurs peuvent créer un code plus robuste et plus compréhensible.


## Exercice : Magic Numbers

### Questions
1. Combien de lignes de code doivent être modifiées pour changer la définition d'une température "basse" à moins de 18°C et plus de 20°C ?
2. Dans le code ci-dessous, retirez tous les magic numbers en les remplaçant par des constantes nommées.

### Code
```python
class AnalyseMeteo:
    def __init__(self, temperatures, humidites):
        self.temperatures = temperatures
        self.humidites = humidites

    def obtenir_journees_chaudes(self):
        # Températures supérieures à 30°C
        return [temp for temp in self.temperatures if temp > 30]

    def verifier_humidite_acceptable(self):
        # Humidité entre 30% et 70%
        return [hum for hum in self.humidites if 30 <= hum <= 70]

    def comment_est_la_journée(self, temperature, humidite):
        # Idéal : Température entre 20°C et 25°C et humidité < 60%
        if 20 <= temperature <= 25 and humidite < 60:
            return print("La journée est idéale")
        if 20 <= temperature <= 25 and humidite > 60:
            return print("La journée a une température idéale, mais un taux d'humidité trop élevé")
        if temperature > 25 and humidite < 60:
            return print("La journée a une température trop élevée, mais un taux d'humidité idéal")
        else:
            return print("La journée n'est pas idéale")
```


## Introduction aux normes de nommage en Python

En Python, des normes et des conventions de nommage existent pour améliorer la lisibilité et la compréhension du code.

### 1. Nommage des fichiers et des modules

- **Convention** : Utilisez des lettres minuscules et des underscores pour séparer les mots. 
- **Exemple** : `mon_script.py`, `utils.py`

### 2. Nommage des classes

- **Convention** : Adoptez le style CamelCase pour les noms de classes, où chaque mot commence par une majuscule.
- **Exemple** : `MaClasse`, `GestionnaireDeFichiers`

### 3. Nommage des variables et des arguments de fonction

- **Convention** : Utilisez des lettres minuscules avec des underscores pour séparer les mots.
- **Exemple** : `ma_variable`, `nombre_utilisateurs`
- **Remarque** : Évitez les noms de variables ambigus ou trop génériques.

### 4. Nommage des fonctions et des méthodes

- **Convention** : Utilisez des lettres minuscules avec des underscores pour les noms de fonctions, comme pour les variables.
- **Exemple** : `calculer_somme`, `obtenir_utilisateur`
- **Remarque** : Les noms de fonctions doivent être descriptifs et indiquer clairement leur objectif.

### 5. Nommage des constantes

- **Convention** : Utilisez des lettres majuscules avec des underscores pour séparer les mots. Les constantes doivent être définies en haut du fichier ou du module.
- **Exemple** : `MAX_TAILLE`, `NOMBRE_MAXI_UTILISATEURS`

### 6. Nommage des packages et des dossiers

- **Convention** : Utilisez des lettres minuscules et évitez les underscores. 
- **Exemple** : `monpackage`, `utilitaires`

### 7. Autres bonnes pratiques

- **Utilisez des mots significatifs** : Choisissez des noms qui décrivent clairement le rôle d'une variable, d'une fonction ou d'une classe.
- **Évitez les abréviations obscures** : Les noms doivent être compréhensibles pour toute personne lisant le code.

Les fonctions et méthodes doivent être nommées en commençant par un verbe à l'infinitif, tandis que tous les autres éléments commencent par un nom.

> Il est préférable d'utiliser des noms longs et explicites plutôt que des noms courts dont la signification n'est claire qu'au moment du développement. N'oubliez pas que dans un vrai projet, vous collaborez avec d'autres personnes, mais aussi avec vous-même dans le futur, qui pourrait avoir oublié le contexte de ce bout de code.

