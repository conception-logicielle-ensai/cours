---
title: üî∞ Bonnes pratiques du d√©veloppement et design patterns
url: "/docs/bonnes-pratiques-dev"
---

Cette partie est largement bas√©e des concepts et exemples pr√©sent√©s dans le livre :

> **Refactoring**, Improving the design of existing code. Martin Fowler, Kent Beck 1999.

Ce livre pr√©sente un ensemble de probl√®mes que l'on peut retrouver dans une base de code et propose une r√©solution de ces probl√®mes par le respect de pratiques et de normes de d√©veloppement.

## Code smells

Les code smells sont des indices dans le code qui sugg√®rent des probl√®mes potentiels, rendant le code difficile √† comprendre, √† maintenir ou √† faire √©voluer. Ils ne sont pas n√©cessairement des bugs, mais indiquent souvent des faiblesses dans la conception, comme des fonctions trop longues, des d√©pendances complexes ou des r√©p√©titions inutiles.

L'identification des code smells aide √† rep√©rer les zones du code qui pourraient b√©n√©ficier d'un refactoring.

> Pour aller plus loin : On retrouve diff√©rents des principaux code smells ici : https://refactoring.guru/refactoring/smells

### Magic Numbers

Le terme "magic number" d√©signe l'utilisation de constantes num√©riques non nomm√©es dans le code source d'un programme. Cette pratique peut rendre le code difficile √† comprendre et √† maintenir, car elle obscurcit le sens des valeurs utilis√©es. En nommant explicitement toutes les constantes, on am√©liore la lisibilit√©, la compr√©hension et la maintenabilit√© du code, ce qui facilite la collaboration entre d√©veloppeurs.

#### Exemple de Code avec Magic Numbers

Voici un exemple illustrant l'utilisation de magic numbers dans le calcul de valeurs extr√™mes et de moyennes glissantes :

```python
import numpy as np

def extreme(data):
    # Calcul de la moyenne et de l'√©cart-type
    mean = np.mean(data)
    std_dev = np.std(data)
    resultat = []  # Liste pour stocker les valeurs extr√™mes
    for x in data:
        if abs(x - mean) > 3 * std_dev: 
            resultat.append(x)  # Utilisation de append pour ajouter des √©l√©ments
    return resultat  # Retourne la liste des valeurs extr√™mes

# Calcul de la moyenne glissante sur une fen√™tre de taille 3
def moyenne_glissante(data):
    """
    Calcule une moyenne glissante sur une fen√™tre de taille 3.
    Les bords o√π il n'y a pas assez de valeurs retournent None.
    """
    if len(data) < 3:
        return [None] * len(data)

    resultats = [None]  # Padding initial pour le bord gauche
    for i in range(1, len(data) - 1):
        moyenne = np.mean(data[i - 1:i + 2])  # Calcul de la moyenne glissante
        resultats.append(moyenne)
    resultats.append(None)  # Padding final pour le bord droit
    return resultats

# Donn√©es
data = [100, 102, 98, 97, 250, 101, 99, 102]
# Identification des valeurs extr√™mes (plus de 3 √©carts-types de la moyenne)
extremes = extreme(data)
print(f"Valeurs extr√™mes : {extremes}")
# Calcul et affichage de la moyenne glissante
glissement = moyenne_glissante(data)
print(f"Moyenne glissante sur 3 : {glissement}")
```

<details><summary><b>Pourquoi √©viter les Magic Numbers ? (Cliquez ici pour en savoir plus)</b></summary>
<p>

<h3>Pourquoi √âviter les Magic Numbers ?</h3>

L'utilisation de **magic numbers** dans le code pr√©sente plusieurs inconv√©nients majeurs :

- **Manque de clart√©** : Lorsqu'un d√©veloppeur lit le code, il peut se demander : ¬´ Pourquoi cette valeur ? ¬ª. Par exemple, une condition impliquant la valeur `3` pour un √©cart-type peut sembler arbitraire. Cela complique la compr√©hension rapide du code et n√©cessite une r√©flexion suppl√©mentaire pour deviner la signification de la valeur.

- **Ambigu√Øt√©** : Les magic numbers peuvent pr√™ter √† confusion lorsqu'ils sont utilis√©s pour repr√©senter des concepts diff√©rents dans le m√™me programme. Par exemple, si deux variables distinctes partagent la m√™me valeur, cela complique l'identification de leur r√¥le respectif.

- **Difficult√© de maintenance** : Modifier une valeur magique peut entra√Æner des erreurs, car cette valeur est souvent utilis√©e √† plusieurs endroits. Par exemple, pour passer d'une taille de moyenne glissante de `3` √† `5`, un d√©veloppeur pourrait remplacer toutes les occurrences de `3` par `5`. Cela risque d'introduire des bugs, notamment si certaines parties du code, comme une expression du type `[i - 1:i + 2]`, ne sont pas correctement adapt√©es.

</p>
</details>


#### Am√©lioration du Code

Pour √©viter l'utilisation de magic numbers, il est pr√©f√©rable de d√©finir des constantes nomm√©es :

```python
import numpy as np

# D√©finition des constantes
TAILLE_FENETRE_GLISSANTE = 3
MULTIPLICATEUR_SEUIL = 3

def extreme(data):
    # Calcul de la moyenne et de l'√©cart-type
    mean = np.mean(data)
    std_dev = np.std(data)
    resultat = []  # Liste pour stocker les valeurs extr√™mes
    for x in data:
        if abs(x - mean) > MULTIPLICATEUR_SEUIL * std_dev:  # Utilisation de la constante
            resultat.append(x)
    return resultat  # Retourne la liste des valeurs extr√™mes

# Calcul de la moyenne glissante sur une fen√™tre de taille d√©finie
def moyenne_glissante(data):
    """
    Calcule une moyenne glissante sur une fen√™tre de taille d√©finie.
    Les bords o√π il n'y a pas assez de valeurs retournent None.
    """
    if len(data) < TAILLE_FENETRE_GLISSANTE:
        return [None] * len(data)

    resultats = [None]  # Padding initial pour le bord gauche
    for i in range(1, len(data) - 1):
        moyenne = np.mean(data[i - 1:i + TAILLE_FENETRE_GLISSANTE - 1])  # Utilisation de la constante
        resultats.append(moyenne)
    resultats.append(None)  # Padding final pour le bord droit
    return resultats

# Donn√©es
data = [100, 102, 98, 97, 250, 101, 99, 102]
# Identification des valeurs extr√™mes (plus de 3 √©carts-types de la moyenne)
extremes = extreme(data)
print(f"Valeurs extr√™mes : {extremes}")
# Calcul et affichage de la moyenne glissante
glissement = moyenne_glissante(data)
print(f"Moyenne glissante sur 3 : {glissement}")
```

Dans ce code am√©lior√©, la modification de la valeur de `TAILLE_FENETRE_GLISSANTE` ou `MULTIPLICATEUR_SEUIL` ne n√©cessite qu'une seule intervention, ce qui facilite la maintenance.

#### Comment √âviter les Magic Numbers ?

Pour √©viter les magic numbers :

- **Utilisez des Constantes Nomm√©es** : D√©clarez les constantes en MAJUSCULES au d√©but de vos fichiers ou fonctions. Cela facilite leur recherche et modification. Par exemple, `MULTIPLICATEUR_SEUIL = 3` peut √™tre consid√©r√© comme une v√©rit√© statistique, donc il est peu probable qu'elle change.

- **Param√®tres de Fonction** : Pour les valeurs qui peuvent n√©cessiter des ajustements, passez-les en param√®tres de fonction. Par exemple, dans `moyenne_glissante`, cela a plus de sens de les traiter comme un param√®tre, ce qui permet d'associer une valeur explicite √† la fen√™tre glissante.


Les probl√®mes li√©s aux magic numbers ne se limitent pas aux constantes num√©riques. Ce terme s'applique √©galement √† d'autres types de donn√©es. Par exemple, d√©clarer const string testNomUtilisateur = "Jean" est pr√©f√©rable √† l'utilisation directe du mot "Jean" √† plusieurs endroits dans le programme.

> En gros d√®s que vous avez des string ou des nombre (entier ou flotant) √©crit en dur, c'est que vous avez mal fait les chose.

### Code Dupliqu√©

Le code dupliqu√© est un probl√®me fr√©quent qui peut rendre votre programme plus difficile √† maintenir. Chaque fois que vous dupliquez des structures similaires dans votre code, vous introduisez un risque d'incoh√©rence. Si vous devez modifier une de ces copies, vous devez vous assurer que toutes les autres sont mises √† jour en cons√©quence. Cela augmente la probabilit√© d'erreurs et complique la lecture et l'√©volution du code. La solution consiste √† unifier ces duplications en extrayant les parties communes.

---

#### **1. Si le code dupliqu√© se trouve dans la m√™me classe**

Code avec des lignes dupliqu√©es :

```python
class Calculateur:
    def calculer_area_rectangle(self, largeur, hauteur):
        print("L'aire d'un rectangle est largeur * hauteur")
        return largeur * hauteur

    def calculer_area_carre(self, cote):
        print("L'aire d'un carr√© est cote * cote")
        return cote * cote
```

Dans cet exemple, la logique de multiplication est r√©p√©t√©e dans les deux m√©thodes. Pour √©viter cette duplication, nous pouvons extraire cette logique dans une m√©thode utilitaire.

Code mutualis√© :

```python
class Calculateur:
    def multiplier(self, a, b):
        return a * b  # M√©thode extraite pour √©viter la duplication

    def calculer_area_rectangle(self, largeur, hauteur):
        print("L'aire d'un rectangle est largeur * hauteur")
        return self.multiplier(largeur, hauteur)

    def calculer_area_carre(self, cote):
        print("L'aire d'un carr√© est cote * cote")
        return self.multiplier(cote, cote)
```

#### **2. Si le code dupliqu√© se trouve dans des sous-classes**

Code avec des lignes dupliqu√©es :

```python
class Forme:
    def area(self):
        pass  # M√©thode √† impl√©menter dans les sous-classes

class Rectangle(Forme):
    def __init__(self, largeur, hauteur):
        self.largeur = largeur
        self.hauteur = hauteur

    def area(self):
        print("L'aire d'un rectangle est largeur * hauteur")
        return self.largeur * self.hauteur

class Carre(Forme):
    def __init__(self, cote):
        self.cote = cote

    def area(self):
        print("L'aire d'un carr√© est cote * cote")
        return self.cote * self.cote
```

Ici, la logique de multiplication est dupliqu√©e dans les m√©thodes `area` de `Rectangle` et `Carre`. Pour √©viter cette duplication, nous pouvons utiliser la **m√©thode Pull Up**, qui consiste √† d√©placer le code commun dans la classe de base.

Code mutualis√© avec la m√©thode Pull Up :

```python
class Forme:
    def multiplier(self, a, b):
        return a * b  # M√©thode partag√©e pour √©viter la duplication

    def area(self):
        pass  # M√©thode g√©n√©rique √† sp√©cialiser dans les sous-classes

class Rectangle(Forme):
    def __init__(self, largeur, hauteur):
        self.largeur = largeur
        self.hauteur = hauteur

    def area(self):
        print("L'aire d'un rectangle est largeur * hauteur")
        return self.multiplier(self.largeur, self.hauteur)

class Carre(Forme):
    def __init__(self, cote):
        self.cote = cote

    def area(self):
        print("L'aire d'un carr√© est cote * cote")
        return self.multiplier(self.cote, self.cote)
```

---

Le refactoring est un processus it√©ratif : commencez par des petits changements, testez r√©guli√®rement et continuez √† am√©liorer le code progressivement.

### Fonctions trop longues

Dans la programmation, il est souvent observ√© qu'une fonction trop longue devient difficile √† comprendre. Dans le pass√©, les anciens langages de programmation avaient un inconv√©nient : appeler une sous-fonction √©tait co√ªteux en termes de performance, ce qui dissuadait les d√©veloppeurs d‚Äôutiliser des petites fonctions. Cependant, avec les langages modernes, ce co√ªt est presque inexistant lorsqu‚Äôon reste dans le m√™me processus.

Aujourd'hui, la v√©ritable contrainte li√©e aux petites fonctions r√©side dans le fait qu'elles demandent parfois un effort suppl√©mentaire √† ceux qui lisent le code, car il faut ouvrir chaque fonction pour comprendre son r√¥le. Heureusement, les outils de d√©veloppement modernes nous simplifient la t√¢che : on peut naviguer facilement vers la d√©finition d'une fonction ou afficher son contenu d'un simple clic.

Le v√©ritable avantage des petites fonctions, c'est leur nom. Un nom clair et pr√©cis permet souvent de comprendre rapidement ce que fait la fonction, sans m√™me avoir besoin d'en lire le contenu.

Prenons un exemple de fonction qui calcule le total d'une commande :

```java
public double calculerTotalCommande(List<Article> articles) {
    double total = 0;
    for (Article article : articles) {
        if (article.isEnPromotion()) {
            total += article.getPrix() * 0.9; // Remise de 10%
            if (article.getQuantite() > 5) {
                total += article.getPrix() * 0.05; // Remise suppl√©mentaire pour les gros achats
            }
        } else {
            total += article.getPrix();
        }
    }
    return total;
}
```

Ici, un bloc de code qui est accompagn√© d‚Äôun commentaire peut √™tre remplac√© par une m√©thode dont le nom r√©sume cette explication. M√™me une simple ligne de code peut justifier son extraction si elle n√©cessite un √©claircissement. Les conditions et les boucles nous donnent √©galement des pistes pour effectuer cette extraction. Par exemple, un gros switch peut √™tre divis√© en appels de fonctions individuelles, et si plusieurs switch utilisent les m√™mes conditions, on peut appliquer le polymorphisme pour am√©liorer la lisibilit√©.

Pour les boucles, il est √©galement judicieux d'extraire la boucle et son contenu dans une m√©thode s√©par√©e. Si vous avez du mal √† nommer une boucle extraite, cela peut indiquer qu'elle r√©alise deux t√¢ches diff√©rentes. Dans ce cas, n‚Äôh√©sitez pas √† diviser les boucles pour isoler les diff√©rentes t√¢ches.

Voici comment nous pourrions refactoriser la fonction pour la rendre plus lisible :

```java
public double calculerTotalCommande(List<Article> articles) {
    double total = 0;
    for (Article article : articles) {
        total += calculerPrixArticle(article);
    }
    return total;
}

private double calculerPrixArticle(Article article) {
    double prixFinal = article.getPrix();
    if (article.isEnPromotion()) {
        prixFinal *= 0.9; // Remise de 10%
        prixFinal -= calculerRemiseSupplementaire(article);
    }
    return prixFinal;
}

private double calculerRemiseSupplementaire(Article article) {
    return article.getQuantite() > 5 ? article.getPrix() * 0.05 : 0; // Remise suppl√©mentaire pour les achats de plus de 5 articles
}
```

### Liste de param√®tres longues

Lorsque vous programmez, vous avez probablement appris √† passer tous les √©l√©ments n√©cessaires √† une fonction en tant que param√®tres. Cependant, avoir une longue liste de param√®tres peut rapidement devenir source de confusion.

Je vais vous pr√©senter deux cas pour illustrer ce point.

#### Cas 1 : Tous les param√®tres proviennent de la m√™me classe

Prenons l‚Äôexemple d‚Äôune classe `Voiture` qui a plusieurs attributs :

```python
class Voiture:
    def __init__(self, marque, modele, annee, couleur, kilometrage, prix):
        self.marque = marque
        self.modele = modele
        self.annee = annee
        self.couleur = couleur
        self.kilometrage = kilometrage
        self.prix = prix
        # D'autres attributs non n√©cessaires pour la m√©thode d'affichage
        self.type_carburant = None
        self.nombre_portes = None

class GestionnaireDeVoiture:
    @staticmethod
    def afficher_informations_voiture(marque, modele, annee, couleur, kilometrage, prix):
        print(f"Voiture: {marque} {modele}, {annee} - "
              f"Couleur: {couleur}, Kilom√©trage: {kilometrage} km, "
              f"Prix: {prix} ‚Ç¨.")
```

Ici, lorsque nous voulons afficher les informations de la voiture, nous devons passer tous ses attributs comme param√®tres :

```python
# Utilisation
ma_voiture = Voiture("Toyota", "Corolla", 2020, "Rouge", 15000, 20000)

# Appel de la m√©thode avec une longue liste de param√®tres
GestionnaireDeVoiture.afficher_informations_voiture(
    ma_voiture.marque,
    ma_voiture.modele,
    ma_voiture.annee,
    ma_voiture.couleur,
    ma_voiture.kilometrage,
    ma_voiture.prix
)
```

Dans ce cas, m√™me si tous les attributs ne sont pas n√©cessaires √† la m√©thode, il est pr√©f√©rable de passer l'objet complet. C'est ce qu'on appelle le principe de **Pr√©server l'Objet Complet** :

```python
class GestionnaireDeVoiture:
    @staticmethod
    def afficher_informations_voiture(voiture):
        print(f"Voiture: {voiture.marque} {voiture.modele}, {voiture.annee} - "
              f"Couleur: {voiture.couleur}, Kilom√©trage: {voiture.kilometrage} km, "
              f"Prix: {voiture.prix} ‚Ç¨.")
```

Maintenant, nous pouvons appeler la m√©thode de cette mani√®re :

```python
# Appel de la m√©thode statique avec l'objet complet
GestionnaireDeVoiture.afficher_informations_voiture(ma_voiture)
```

#### Cas 2 : Les param√®tres proviennent de classes diff√©rentes

Imaginons maintenant que nous ayons une classe `Personne` et une classe `Adresse` :

```python
class Personne:
    def __init__(self, nom, prenom, age):
        self.nom = nom
        self.prenom = prenom
        self.age = age
        # D'autres attributs
        self.sexe = None
        self.date_naissance = None

class Adresse:
    def __init__(self, rue, ville, code_postal):
        self.rue = rue
        self.ville = ville
        self.code_postal = code_postal
        # D'autres attributs
        self.pays = None
        self.region = None

def envoyer_invitation(nom, prenom, age, rue, ville, code_postal):
    print(f"Invitation envoy√©e √† {prenom} {nom}, {age} ans, √† l'adresse suivante : {rue}, "
          f"{ville}, {code_postal}.")
```

Dans cet exemple, nous devons passer plusieurs param√®tres provenant de deux classes diff√©rentes :

```python
# Utilisation
personne = Personne("Dupont", "Jean", 30)
adresse = Adresse("10 Rue des Fleurs", "Paris", "75000")

# Appel de la fonction avec une longue liste de param√®tres
envoyer_invitation(
    personne.nom,
    personne.prenom,
    personne.age,
    adresse.rue,
    adresse.ville,
    adresse.code_postal
)
```

Pour simplifier cela, nous pouvons combiner les informations de la personne et de l'adresse en un seul objet. C'est ce qu'on appelle le principe d‚Äô**Introduire un Objet Param√®tre**. Cela est encore plus utile si ces attributs sont souvent utilis√©s ensemble :

```python
class InformationsClient:
    def __init__(self, personne, adresse):
        self.nom = personne.nom
        self.prenom = personne.prenom
        self.age = personne.age
        self.rue = adresse.rue
        self.ville = adresse.ville
        self.code_postal = adresse.code_postal

class GestionnaireDeClient:
    @staticmethod
    def envoyer_invitation(informations_client):
        print(f"Invitation envoy√©e √† {informations_client.prenom} {informations_client.nom}, "
              f"{informations_client.age} ans, √† l'adresse suivante : {informations_client.rue}, "
              f"{informations_client.ville}, {informations_client.code_postal}.")
```

Voici comment nous utilisons ce nouveau syst√®me :

```python
# Utilisation
personne = Personne("Dupont", "Jean", 30)
adresse = Adresse("10 Rue des Fleurs", "Paris", "75000")
informations_client = InformationsClient(personne, adresse)

GestionnaireDeClient.envoyer_invitation(informations_client)
```



> Il existe de nombreux autres types de *code smells*, tels que les **Noms myst√©rieux**, qui d√©signent des noms de variables ou de fonctions peu clairs et ambigus, et la **Mutabilit√© des variables**, qui se r√©f√®re √† la modification d'une variable apr√®s sa cr√©ation, rendant le code moins pr√©visible. Bien que nous n'ayons pas le temps d'explorer ces concepts en cours, je vous encourage √† faire des recherches √† leur sujet, notamment dans le livre mentionn√© dans l'introduction.

## Normalisation des nommages : Introduction aux normes de nommage en Python

Des normes et des conventions de nommage existent pour am√©liorer la lisibilit√©, la maintenabilit√© et la compr√©hension du code. Chaque langage a ses propres normes et conventions, adapt√©es √† ses particularit√©s. 

Par exemple : 
- En **Python**, les variables sont g√©n√©ralement nomm√©es en `snake_case`.
- En **Java**, on pr√©f√®re le `camelCase` pour les noms de variables et de m√©thodes.

Les conventions de codage en Python sont d√©finies dans la [PEP 8](https://peps.python.org/pep-0008/), tandis que celles de Java sont d√©crites dans le document officiel [Code Conventions for the Java Programming Language](https://www.oracle.com/java/technologies/javase/codeconventions-contents.html).

Nous vous encourageons vivement √† consulter ces ressources pour d√©couvrir davantage d‚Äôexemples pr√©cis et des explications d√©taill√©es sur ces conventions. Leur respect permet de garantir un code clair, coh√©rent et facilement compr√©hensible, notamment dans un contexte de collaboration.


#### 1. Nommage des fichiers et des modules

- **Convention** : Utilisez des lettres minuscules et des underscores pour s√©parer les mots. 
- **Exemple** : `mon_script.py`, `utils.py`

#### 2. Nommage des classes

- **Convention** : Adoptez le style PascalCase pour les noms de classes, o√π chaque mot commence par une majuscule.
- **Exemple** : `MaClasse`, `GestionnaireDeFichiers`

#### 3. Nommage des variables et des arguments de fonction

- **Convention** : Utilisez des lettres minuscules avec des underscores pour s√©parer les mots.
- **Exemple** : `ma_variable`, `nombre_utilisateurs`
- **Remarque** : √âvitez les noms de variables ambigus ou trop g√©n√©riques.

#### 4. Nommage des fonctions et des m√©thodes

- **Convention** : Utilisez des lettres minuscules avec des underscores pour les noms de fonctions, comme pour les variables.
- **Exemple** : `calculer_somme`, `obtenir_utilisateur`
- **Remarque** : Les noms de fonctions doivent √™tre descriptifs et indiquer clairement leur objectif.

#### 5. Nommage des constantes

- **Convention** : Utilisez des lettres majuscules avec des underscores pour s√©parer les mots. Les constantes doivent √™tre d√©finies en haut du fichier ou du module.
- **Exemple** : `MAX_TAILLE`, `NOMBRE_MAXI_UTILISATEURS`

#### 6. Nommage des packages et des dossiers
- **Convention** : Utilisez des lettres minuscules et √©vitez les underscores. 
- **Exemple** : `monpackage`, `utilitaires`

#### 7. Autres bonnes pratiques

- **Utilisez des mots significatifs** : Choisissez des noms qui d√©crivent clairement le r√¥le d'une variable, d'une fonction ou d'une classe.
- **√âvitez les abr√©viations obscures** : Les noms doivent √™tre compr√©hensibles pour toute personne lisant le code.

Les fonctions et m√©thodes doivent √™tre nomm√©es en commen√ßant par un verbe √† l'infinitif, tandis que tous les autres √©l√©ments commencent par un nom.

> Il est pr√©f√©rable d'utiliser des noms longs et explicites plut√¥t que des noms courts dont la signification n'est claire qu'au moment du d√©veloppement. N'oubliez pas que dans un vrai projet, vous collaborez avec d'autres personnes, mais aussi avec vous-m√™me dans le futur, qui pourrait avoir oubli√© le contexte de ce bout de code.


## Patrons de conception 

Cette partie est largement bas√©e sur les 23 design patterns pr√©sent√©s dans le livre : 

> Design Patterns: Elements of Reusable Object-Oriented Software (Addison-Wesley Professional Computing Series), Gamma Erich, Richard Helm, Ralph Johnson, John Vissidies, 1994


Les patrons de conception ou design patterns sont des arrangements caract√©ristiques logiques permettant la bonne conception de modules applicatifs logiciels en Programmation Orient√©e Objet. Il en existe une multitude r√©pondant a des probl√©matiques de r√©utilisabilit√© et d'impl√©mentation qualitative.

> En g√©n√©ral, on pr√©sente un patron en r√©ponse a une probl√©matique

### Gang of Four (GoF), ou le conseil des 23 (et non 4) 

On distingue classiquement 3 cat√©gories des 23 design patterns classiques : 
- Les Cr√©ationnels (structurent la mani√®re de cr√©er des objets).
- Les Structuraux (organisent les relations entre les classes et les objets).
- Les Comportementaux (d√©finissent comment les objets interagissent entre eux).

> Remarque : L'on retrouve une liste exhaustive des 23 ici : https://refactoring.guru/fr/design-patterns/catalog

Dans les faits, leur mise en place est sp√©cifique a diff√©rentes situations, il est important de garder a l'esprit leur existence pour l'application dans des cas appropri√©s.

### Quelques exemples

Dans cette partie on retrouve diff√©rents patterns que l'on pr√©sente dans le cadre de ce cours et que l'on souhaiterait voir appliqu√©s a diff√©rents √©l√©ments de vos logiciels.

#### 1. `Singleton` : 

Dans votre projet , l'utilitaire de connexion a la base de donn√©es √©tait unique.

> Le design pattern singleton isole le constructeur d'une classe et en fournit une impl√©mentation unique par le biais d'un remplacement de ce constructeur a un get d'une instance **statique**. Cela permet d'avoir une seule et unique configuration dans tout le code.

Cas d'application :
- **Logger**
- **Connecteur SGBD**
- **Gestionnaire d'authentification**
...

#### 2. `Data Transfer Object` : 

Le pattern DTO (Data Transfer Object) est utilis√© pour transporter des donn√©es entre diff√©rentes couches d'une application.

> Il a √©t√© d√©fini dans le livre : `Patterns of Enterprise Application Architecture` https://martinfowler.com/books/eaa.html

Il permet :

- De s√©parer les donn√©es de transfert des entit√©s m√©tier pour √©viter de les exposer directement.
- De centraliser la validation des donn√©es avant qu'elles ne soient utilis√©es par les couches m√©tier.
- D'am√©liorer la s√©curit√© et la maintenabilit√© en contr√¥lant pr√©cis√©ment ce qui est transf√©r√© et expos√©.

Un DTO est g√©n√©ralement utilis√© dans le contexte d'une API ou d'un syst√®me distribu√© pour s√©rialiser et d√©s√©rialiser les donn√©es entrantes/sortantes.

Exemple dans le cadre d'une api FastAPI pour la validation d'un User avant de l'entr√©e dans le syst√®me :

```python
from fastapi import HTTPException, Depends, FastAPI
from typing import List

app = FastAPI()

# --- Entit√© m√©tier ---
class UserDTO(BaseModel):
    username: str
    email: str
    def to_user(self):
        """Convert DTO to a plain User object."""
        return User(
            username=self.username,
            email=self.email
        )
class User:
    def __init__(self, username: str, email: str, roles: List[str]):
        self.username = username
        self.email = email
        self.roles = roles

    def __repr__(self):
        return f"User(username={self.username}, email={self.email}, roles={self.roles})"

# --- D√©corateur pour v√©rifier les r√¥les ---
def requires_role(required_role: str):
    """D√©corateur pour v√©rifier qu'un utilisateur a un r√¥le sp√©cifique."""
    def decorator(method):
        def wrapper(user: User, *args, **kwargs):
            if required_role not in user.roles:
                raise HTTPException(status_code=403, detail=f"Access denied. Requires role: {required_role}")
            return method(user, *args, **kwargs)
        return wrapper
    return decorator

class UserDAO:
    def __init__(self, database:Database):
        self.database = database
    def get_user(self,user:User):
        return self.db_session.query(User).filter(User.id == user.username).first()
# --- M√©thode d√©cor√©e ---
class UserService:
    def __init__(self, user_dao:UserDAO):
        self.user_dao = user_dao
    @staticmethod
    @requires_role("admin")
    def peut_se_connecter(user: User):
        """V√©rifie si l'utilisateur peut se connecter (uniquement pour les administrateurs)."""
        return {"message": f"User {user.username} can connect as admin."}
    def fetch_roles(self,user:User):
        updated_user = self.user_dao.fetch_roles(user)
        return updated_user 
# --- API Endpoint ---
@app.post("/connect")
def connect(user_dto: UserDTO = Depends(lambda: UserDto(username="JohnDoe", email="johndoe@example.com"))):
    """
    Endpoint qui utilise la m√©thode `peut_se_connecter` pour v√©rifier si l'utilisateur peut acc√©der.
    Un utilisateur avec le r√¥le "admin" est n√©cessaire.
    """
    return UserService.peut_se_connecter(userDTO.to_user())
```

L'avantage est l'isolation des donn√©es d'entr√©e et de sortie du syst√®me et de ne pas demander la saisie int√©grale du champ user alors que l'on a seulement besoin d'un identifiant ou identifiant et mail par exemple.

> Ô∏è‚Äçüî•Ô∏è‚Äçüî•Ô∏è‚Äçüî• Si l'on doit faire √©voluer, on peut faire √©voluer seulement l'entr√©e, ou seulement l'objet a l'int√©rieur du syst√®me. Ô∏è‚Äçüî•Ô∏è‚Äçüî•Ô∏è‚Äçüî•

