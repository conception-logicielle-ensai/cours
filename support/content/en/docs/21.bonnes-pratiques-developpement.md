---
title: ğŸ”° Bonnes pratiques du dÃ©veloppement et design patterns
url: "/docs/bonnes-pratiques-dev"
---
## âš ï¸ C'est en travaux, revenez plus tard !

Notre page est actuellement en cours d'Ã©criture et nous mettons tout en Å“uvre pour vous offrir la meilleure expÃ©rience possible. Nous vous prions de bien vouloir patienter, elle sera remplie prochainement.

Voici une version rÃ©visÃ©e de votre texte avec la correction idÃ©ale intÃ©grÃ©e et une conclusion amÃ©liorÃ©e :

---


## Magic Numbers

Le terme "magic number" dÃ©signe l'utilisation de constantes numÃ©riques non nommÃ©es dans le code source d'un programme. Cette pratique peut rendre le code difficile Ã  comprendre et Ã  maintenir, car elle obscurcit le sens des valeurs utilisÃ©es. En nommant explicitement toutes les constantes, on amÃ©liore la lisibilitÃ©, la comprÃ©hension et la maintenabilitÃ© du code, ce qui facilite la collaboration entre dÃ©veloppeurs.

### Exemple de Code avec Magic Numbers

Voici un exemple illustrant l'utilisation de magic numbers dans le calcul de valeurs extrÃªmes et de moyennes glissantes :

```python
import numpy as np

def extreme(data):
    # Calcul de la moyenne et de l'Ã©cart-type
    mean = np.mean(data)
    std_dev = np.std(data)
    resultat = []  # Liste pour stocker les valeurs extrÃªmes
    for x in data:
        if abs(x - mean) > 3 * std_dev: 
            resultat.append(x)  # Utilisation de append pour ajouter des Ã©lÃ©ments
    return resultat  # Retourne la liste des valeurs extrÃªmes

# Calcul de la moyenne glissante sur une fenÃªtre de taille 3
def moyenne_glissante(data):
    """
    Calcule une moyenne glissante sur une fenÃªtre de taille 3.
    Les bords oÃ¹ il n'y a pas assez de valeurs retournent None.
    """
    if len(data) < 3:
        return [None] * len(data)

    resultats = [None]  # Padding initial pour le bord gauche
    for i in range(1, len(data) - 1):
        moyenne = np.mean(data[i - 1:i + 2])  # Calcul de la moyenne glissante
        resultats.append(moyenne)
    resultats.append(None)  # Padding final pour le bord droit
    return resultats

# DonnÃ©es
data = [100, 102, 98, 97, 250, 101, 99, 102]
# Identification des valeurs extrÃªmes (plus de 3 Ã©carts-types de la moyenne)
extremes = extreme(data)
print(f"Valeurs extrÃªmes : {extremes}")
# Calcul et affichage de la moyenne glissante
glissement = moyenne_glissante(data)
print(f"Moyenne glissante sur 3 : {glissement}")
```

### Pourquoi Ã‰viter les Magic Numbers ?

L'utilisation de magic numbers prÃ©sente plusieurs inconvÃ©nients :

- **Manque de ClartÃ©** : Lorsqu'un dÃ©veloppeur lit le code, il peut se demander Â« Pourquoi 3 ? Â» pour la condition d'Ã©cart-type. Cela complique la comprÃ©hension rapide du code et nÃ©cessite des rÃ©flexions supplÃ©mentaires pour comprendre le choix de cette valeur.
  
- **AmbiguÃ¯tÃ©** : Les magic numbers peuvent Ãªtre dÃ©routants lorsqu'ils sont utilisÃ©s pour des significations diffÃ©rentes au sein du mÃªme morceau de code. Par exemple, deux variables diffÃ©rentes pourraient avoir la mÃªme valeur, crÃ©ant ainsi une confusion sur leur utilisation.

- **DifficultÃ© de Maintenance** : Modifier une valeur magique peut Ãªtre source d'erreurs, car elle est souvent utilisÃ©e Ã  plusieurs endroits. Par exemple, pour adapter la taille de la moyenne glissante de 3 Ã  5, un dÃ©veloppeur pourrait remplacer toutes les occurrences de 3 par 5. Cela pourrait entraÃ®ner des erreurs, notamment si certaines portions du code, comme l'expression `[i - 1:i + 2]`, ne sont pas mises Ã  jour.

### AmÃ©lioration du Code

Pour Ã©viter l'utilisation de magic numbers, il est prÃ©fÃ©rable de dÃ©finir des constantes nommÃ©es :

```python
import numpy as np

# DÃ©finition des constantes
TAILLE_FENETRE_GLISSANTE = 3
MULTIPLICATEUR_SEUIL = 3

def extreme(data):
    # Calcul de la moyenne et de l'Ã©cart-type
    mean = np.mean(data)
    std_dev = np.std(data)
    resultat = []  # Liste pour stocker les valeurs extrÃªmes
    for x in data:
        if abs(x - mean) > MULTIPLICATEUR_SEUIL * std_dev:  # Utilisation de la constante
            resultat.append(x)
    return resultat  # Retourne la liste des valeurs extrÃªmes

# Calcul de la moyenne glissante sur une fenÃªtre de taille dÃ©finie
def moyenne_glissante(data):
    """
    Calcule une moyenne glissante sur une fenÃªtre de taille dÃ©finie.
    Les bords oÃ¹ il n'y a pas assez de valeurs retournent None.
    """
    if len(data) < TAILLE_FENETRE_GLISSANTE:
        return [None] * len(data)

    resultats = [None]  # Padding initial pour le bord gauche
    for i in range(1, len(data) - 1):
        moyenne = np.mean(data[i - 1:i + TAILLE_FENETRE_GLISSANTE - 1])  # Utilisation de la constante
        resultats.append(moyenne)
    resultats.append(None)  # Padding final pour le bord droit
    return resultats

# DonnÃ©es
data = [100, 102, 98, 97, 250, 101, 99, 102]
# Identification des valeurs extrÃªmes (plus de 3 Ã©carts-types de la moyenne)
extremes = extreme(data)
print(f"Valeurs extrÃªmes : {extremes}")
# Calcul et affichage de la moyenne glissante
glissement = moyenne_glissante(data)
print(f"Moyenne glissante sur 3 : {glissement}")
```

Dans ce code amÃ©liorÃ©, la modification de la valeur de `TAILLE_FENETRE_GLISSANTE` ou `MULTIPLICATEUR_SEUIL` ne nÃ©cessite qu'une seule intervention, ce qui facilite la maintenance.

### Comment Ã‰viter les Magic Numbers ?

Pour Ã©viter les magic numbers :

- **Utilisez des Constantes NommÃ©es** : DÃ©clarez les constantes en MAJUSCULES au dÃ©but de vos fichiers ou fonctions. Cela facilite leur recherche et modification. Par exemple, `MULTIPLICATEUR_SEUIL = 3` peut Ãªtre considÃ©rÃ© comme une vÃ©ritÃ© statistique, donc il est peu probable qu'elle change.

- **ParamÃ¨tres de Fonction** : Pour les valeurs qui peuvent nÃ©cessiter des ajustements, passez-les en paramÃ¨tres de fonction. Par exemple, dans `moyenne_glissante`, cela a plus de sens de les traiter comme un paramÃ¨tre, ce qui permet d'associer une valeur explicite Ã  la fenÃªtre glissante.

### Conclusion
Les problÃ¨mes liÃ©s aux magic numbers ne se limitent pas aux constantes numÃ©riques. Ce terme s'applique Ã©galement Ã  d'autres types de donnÃ©es. Par exemple, dÃ©clarer const string testNomUtilisateur = "Jean" est prÃ©fÃ©rable Ã  l'utilisation directe du mot "Jean" Ã  plusieurs endroits dans le programme.

En gros dÃ¨s que vous avez des string ou des nombre (entier ou flotant) Ã©crit en dur, c'est que vous avez mal fait les chose.
Adopter des pratiques pour Ã©viter les magic numbers permet non seulement d'amÃ©liorer la clartÃ© et la lisibilitÃ© du code, mais aussi d'assurer une maintenance plus simple et moins sujette aux erreurs. En utilisant des constantes nommÃ©es et des paramÃ¨tres de fonction, les dÃ©veloppeurs peuvent crÃ©er un code plus robuste et plus comprÃ©hensible.


## Exercice : Magic Numbers

### Questions
1. Combien de lignes de code doivent Ãªtre modifiÃ©es pour changer la dÃ©finition d'une tempÃ©rature "basse" Ã  moins de 18Â°C et plus de 20Â°C ?
2. Dans le code ci-dessous, retirez tous les magic numbers en les remplaÃ§ant par des constantes nommÃ©es.

### Code
```python
class AnalyseMeteo:
    def __init__(self, temperatures, humidites):
        self.temperatures = temperatures
        self.humidites = humidites

    def obtenir_journees_chaudes(self):
        # TempÃ©ratures supÃ©rieures Ã  30Â°C
        return [temp for temp in self.temperatures if temp > 30]

    def verifier_humidite_acceptable(self):
        # HumiditÃ© entre 30% et 70%
        return [hum for hum in self.humidites if 30 <= hum <= 70]

    def comment_est_la_journÃ©e(self, temperature, humidite):
        # IdÃ©al : TempÃ©rature entre 20Â°C et 25Â°C et humiditÃ© < 60%
        if 20 <= temperature <= 25 and humidite < 60:
            return print("La journÃ©e est idÃ©ale")
        if 20 <= temperature <= 25 and humidite > 60:
            return print("La journÃ©e a une tempÃ©rature idÃ©ale, mais un taux d'humiditÃ© trop Ã©levÃ©")
        if temperature > 25 and humidite < 60:
            return print("La journÃ©e a une tempÃ©rature trop Ã©levÃ©e, mais un taux d'humiditÃ© idÃ©al")
        else:
            return print("La journÃ©e n'est pas idÃ©ale")
```


## Introduction aux normes de nommage en Python

En Python, des normes et des conventions de nommage existent pour amÃ©liorer la lisibilitÃ© et la comprÃ©hension du code.

### 1. Nommage des fichiers et des modules

- **Convention** : Utilisez des lettres minuscules et des underscores pour sÃ©parer les mots. 
- **Exemple** : `mon_script.py`, `utils.py`

### 2. Nommage des classes

- **Convention** : Adoptez le style CamelCase pour les noms de classes, oÃ¹ chaque mot commence par une majuscule.
- **Exemple** : `MaClasse`, `GestionnaireDeFichiers`

### 3. Nommage des variables et des arguments de fonction

- **Convention** : Utilisez des lettres minuscules avec des underscores pour sÃ©parer les mots.
- **Exemple** : `ma_variable`, `nombre_utilisateurs`
- **Remarque** : Ã‰vitez les noms de variables ambigus ou trop gÃ©nÃ©riques.

### 4. Nommage des fonctions et des mÃ©thodes

- **Convention** : Utilisez des lettres minuscules avec des underscores pour les noms de fonctions, comme pour les variables.
- **Exemple** : `calculer_somme`, `obtenir_utilisateur`
- **Remarque** : Les noms de fonctions doivent Ãªtre descriptifs et indiquer clairement leur objectif.

### 5. Nommage des constantes

- **Convention** : Utilisez des lettres majuscules avec des underscores pour sÃ©parer les mots. Les constantes doivent Ãªtre dÃ©finies en haut du fichier ou du module.
- **Exemple** : `MAX_TAILLE`, `NOMBRE_MAXI_UTILISATEURS`

### 6. Nommage des packages et des dossiers

- **Convention** : Utilisez des lettres minuscules et Ã©vitez les underscores. 
- **Exemple** : `monpackage`, `utilitaires`

### 7. Autres bonnes pratiques

- **Utilisez des mots significatifs** : Choisissez des noms qui dÃ©crivent clairement le rÃ´le d'une variable, d'une fonction ou d'une classe.
- **Ã‰vitez les abrÃ©viations obscures** : Les noms doivent Ãªtre comprÃ©hensibles pour toute personne lisant le code.

Les fonctions et mÃ©thodes doivent Ãªtre nommÃ©es en commenÃ§ant par un verbe Ã  l'infinitif, tandis que tous les autres Ã©lÃ©ments commencent par un nom.

> Il est prÃ©fÃ©rable d'utiliser des noms longs et explicites plutÃ´t que des noms courts dont la signification n'est claire qu'au moment du dÃ©veloppement. N'oubliez pas que dans un vrai projet, vous collaborez avec d'autres personnes, mais aussi avec vous-mÃªme dans le futur, qui pourrait avoir oubliÃ© le contexte de ce bout de code.

